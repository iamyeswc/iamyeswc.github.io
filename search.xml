<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>每日一题12.18-12.22</title>
    <url>/dailyQuestion12-18-12-22/</url>
    <content><![CDATA[<h2 id="12-18"><a href="#12-18" class="headerlink" title="12.18"></a>12.18</h2><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p><a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态规划</p>
<p>当前能偷到的最大值：偷当前的+dp[ i - 2]  和 不偷当前的即 dp[ i - 1]  取两个中的大的值</p>
<ul>
<li>状态转移方程</li>
</ul>
<p>dp[ i ] &#x3D; max(dp[ i - 2 ] + num [ i ], dp[ i - 1])</p>
<ul>
<li>初始化</li>
</ul>
<p>因为不能连着偷 , 所以位置 0<del>，1</del>就是当前num的值</p>
<p>第0个： dp[ 0 ] &#x3D; num [ 0 ]</p>
<p>第1个：<del>dp[ 1 ] &#x3D; num[ 1 ]</del></p>
<p>（第1个可以选择不偷当前 偷上一个，或者是偷当前的）</p>
<p>所以应该是</p>
<p>dp[ 1 ] &#x3D; max(num [ 0 ], num[ 1 ])</p>
<table>
<thead>
<tr>
<th>第0个</th>
<th>第1个</th>
<th>..</th>
<th>第i个</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>num[ 0 ] &#x3D; dp [ 0 ]</td>
<td>dp[ 1 ] &#x3D; max(num [ 0 ], num[ 1 ])</td>
<td></td>
<td>dp[ i ] &#x3D; max(dp[ i - 2 ] + num [ i ], dp[ i - 1])</td>
<td></td>
</tr>
</tbody></table>
<p>note: 还需要处理 如果num长度只有1的特殊情况</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> rob(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 0.特殊情况，如果nums长度只有1（1 &lt;= nums.length &lt;= 100）</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp(nums.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.状态转移方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//0.特殊情况</span></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="comment">//1.初始化</span></span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">if</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] &#123;</span><br><span class="line">		dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dp[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.状态转移方程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> dp[i<span class="number">-1</span>] &gt; dp[i<span class="number">-2</span>]+nums[i] &#123;</span><br><span class="line">			dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i] = dp[i<span class="number">-2</span>] + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h2><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>因为需要时间复杂度为 <code>O(n)</code> 的算法</p>
<p>因此 使用哈希表，这样查找 插入的时间复杂度是O(1)</p>
<p>（1）把数字放入unordered_set内</p>
<p>（2）循环：时间复杂度是O(n)</p>
<ul>
<li><p>在unordered_set中对每个数字查找找到连续序列的<strong>起始元素</strong>, 即<strong>不存在比自身还小1</strong>的数字</p>
</li>
<li><p>当找到后就确定了连续数列的起始值，遍历找到连续数列的长度（每次都加1，判断是否在unordered_set里）</p>
<blockquote>
<p>当确定了起始值的遍历，时间复杂度是O(n)， 因为每个数字只会进入一次遍历里面</p>
</blockquote>
</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.放入set内</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">numsSet</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.对set中每个数字进行查找, 找到连续序列的起始元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2.1 当前值是起始元素</span></span><br><span class="line">            <span class="keyword">if</span> (numsSet.<span class="built_in">find</span>(nums[i] - <span class="number">1</span>) == numsSet.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.2 找到从当前值开始最长的序列</span></span><br><span class="line">                <span class="type">int</span> currentNum = nums[i];</span><br><span class="line">                <span class="type">int</span> currentLength = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (numsSet.<span class="built_in">find</span>(currentNum + <span class="number">1</span>) != numsSet.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    currentLength++;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(maxLength, currentLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h5><p>插入map, 把nums里的值作为key， 这样可以利用</p>
<p>**_, exists :&#x3D; numsMap[key-1]**判断是否是连续序列的起始值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line">	numsMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">//1.插入map, 把nums里的值作为key</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		numsMap[nums[i]] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.遍历map, 找起始值</span></span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> numsMap &#123;</span><br><span class="line">		<span class="comment">// 2.1当前值为起始值 找不到比自己小1的数</span></span><br><span class="line">		<span class="keyword">if</span> _, exists := numsMap[key<span class="number">-1</span>]; !exists &#123;</span><br><span class="line">			currentNum := key</span><br><span class="line">			currentLen := <span class="number">1</span></span><br><span class="line">			<span class="comment">// 2.2 找最长的序列</span></span><br><span class="line">			<span class="keyword">for</span> _, exists := numsMap[currentNum+<span class="number">1</span>]; exists; _, exists = numsMap[currentNum+<span class="number">1</span>] &#123;</span><br><span class="line">				currentNum++</span><br><span class="line">				currentLen++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> currentLen &gt; result &#123;</span><br><span class="line">				result = currentLen</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-20"><a href="#12-20" class="headerlink" title="12.20"></a>12.20</h2><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p><a href="https://leetcode.cn/problems/first-missing-positive/">https://leetcode.cn/problems/first-missing-positive/</a></p>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>时间复杂度是O(n) 想到哈希表unordered_set</p>
<blockquote>
<p>理想情况下，查找一个元素（使用unordered_set的find函数）的平均时间复杂度是O(1)，也就是常数时间。然而，在最坏的情况下（例如所有键都哈希到同一bucket时），时间复杂度可以退化到O(n)</p>
</blockquote>
<p>1.把当前nums里的值加入unordered_set</p>
<p>2.从<strong>1</strong>开始遍历，找到unordered_set里<strong>没有出现的值</strong>就是最小正整数</p>
<p><u>虽然这个做法满足时间复杂度是O(n) ，但是用了额外的unordered_set， 空间复杂度是O(n), 不满足常数级别的空间复杂度</u></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h5 id="c-2"><a href="#c-2" class="headerlink" title="c++"></a>c++</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 1. 插入unordered_set</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">uset</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从1开始遍历是否在unordered_set里</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2.1 不在里面说明是最小的正整数</span></span><br><span class="line">            <span class="keyword">if</span> (!uset.<span class="built_in">count</span>(result))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="go-2"><a href="#go-2" class="headerlink" title="go"></a>go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	mp := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	result := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.插入哈希表</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		mp[nums[i]] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.从1开始遍历</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//2.1找不到就是最小正整数</span></span><br><span class="line">		<span class="keyword">if</span> _, exists := mp[result]; !exists &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p><u>要使得时间复杂度是O(n), 那只能对n个数遍历一次</u></p>
<p><u>空间复杂度是常数级别，那就不能构造新的结构（哈希表），要在原始的数组上操作</u></p>
<ul>
<li><p>对于长度为n的数组，如果值是从1到n， 最小的正整数也是n+1, 否则 最小正整数是在1~n之间</p>
</li>
<li><p>因此只需要关注1~n之间是否有不在数组里的值即可（如果都在数组里，则答案就是n+1）</p>
</li>
</ul>
<p>综上， 题目是两种情况：</p>
<p>正面： 答案在1~n之间</p>
<p>反面：答案是n+1</p>
<p>当在正面情况下找不到的时候 答案肯定是n+1</p>
<p>所以此题简化为<strong>找1~n是否都在数组里</strong></p>
<p>因为要省空间，所以要利用原数组</p>
<ol>
<li><p>对于负数和大于数组长度的值统一赋值为n+1， 让数组的值都为正整数</p>
</li>
<li><p>利用数组索引和nums的值对应（索引 +1 &#x3D; i )， 如果 i 在数组里，则将nums[ i -1] 的位置的值 写为负数 （当前值的负数）</p>
</li>
<li><p>最终遍历完数组，正整数的值所在的索引+1 就是1 ~ n中没有出现的正整数</p>
<p>如果都为负数，那答案就是n+1</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>第0个</th>
<th>第1个</th>
<th>第2个</th>
<th>第3个</th>
</tr>
</thead>
<tbody><tr>
<td>原始数组</td>
<td>3</td>
<td>4</td>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>负数转换为n+1</td>
<td>3</td>
<td>4</td>
<td><strong>5</strong></td>
<td>1</td>
</tr>
<tr>
<td>开始遍历</td>
<td><u>3</u></td>
<td>4</td>
<td><strong>-5</strong> （3 对应索引 3 -1 &#x3D;2）</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td><u>3</u></td>
<td><u>4</u></td>
<td>-5</td>
<td><strong>-1</strong> （4 对应索引 4 -1 &#x3D;3）</td>
</tr>
<tr>
<td></td>
<td><u>3</u></td>
<td><u>4</u></td>
<td><u>-5</u> （5对应索引 5 - 1&gt; n不处理）</td>
<td>-1</td>
</tr>
<tr>
<td></td>
<td><strong><u>-3</u></strong></td>
<td><u>4</u></td>
<td><u>-5</u></td>
<td><u>-1</u> （1对应索引 1 - 1 &#x3D; 0不处理）</td>
</tr>
</tbody></table>
<p>最后的正整数是4，索引是1，答案是索引1+1 &#x3D; 2</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="c-3"><a href="#c-3" class="headerlink" title="c++"></a>c++</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.转换负数和大于n的值为n+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.找1~n的值是否在nums里（利用索引）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (c &gt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[c - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[c - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 找是否是有正整数存在</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="go-3"><a href="#go-3" class="headerlink" title="go"></a>go</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	result := n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.处理负数和大于n的数为n+1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; n &#123;</span><br><span class="line">			nums[i] = n + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.找1~n是否在数组里 利用索引</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line">		<span class="comment">//2.1 取绝对值</span></span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			c = nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = -nums[i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2.2 找1~n 利用索引赋值为负数</span></span><br><span class="line">		<span class="keyword">if</span> c &gt; n &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> nums[c<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			nums[c<span class="number">-1</span>] = -nums[c<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[c<span class="number">-1</span>] = nums[c<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.找是否有正整数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			result = i + <span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题12.11-12.15</title>
    <url>/dailyQuestion12.11-12.15/</url>
    <content><![CDATA[<h2 id="12-14"><a href="#12-14" class="headerlink" title="12.14"></a>12.14</h2><h3 id="移掉K位数字"><a href="#移掉K位数字" class="headerlink" title="移掉K位数字"></a>移掉K位数字</h3><p><a href="https://leetcode.cn/problems/remove-k-digits/">https://leetcode.cn/problems/remove-k-digits/</a></p>
<p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p>示例 1 ：</p>
<p>输入：num &#x3D; “1432219”, k &#x3D; 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。<br>示例 2 ：</p>
<p>输入：num &#x3D; “10200”, k &#x3D; 1<br>输出：”200”<br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。<br>示例 3 ：</p>
<p>输入：num &#x3D; “10”, k &#x3D; 2<br>输出：”0”<br>解释：从原数字移除所有的数字，剩余为空就是 0 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 105<br>num 仅由若干位数字（0 - 9）组成<br>除了 0 本身之外，num 不含任何前导零</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>贪心法：高位数字的影响比低位数字大，所以需要尽可能让高位的数字小</p>
<p>（1）利用栈，把数字从高位开始依次入栈</p>
<p>入栈的时候判断是否比栈里的数字小 如果是 就一直出栈到k的额度用完，这样保证了小的数字在高位</p>
<p>当k的额度用完 那就把剩下的数字都入栈</p>
<p>如果全部入栈后 k的额度还有 就默认从栈顶开始出栈</p>
<p>（2）出栈所有数字就是结果（需要删除最前面的0）</p>
<p>这时候需要注意：</p>
<p>如果全为0的结果和前面是0后面有数字的情况处理</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>num &#x3D; “1456128”, k &#x3D; 4  预期输出 112 </p>
<p>处理过程：</p>
<p>1.入栈</p>
<table>
<thead>
<tr>
<th>第一个（k&#x3D;4）</th>
<th>第二个（k&#x3D;4）</th>
<th align="left">第三个（k&#x3D;4）</th>
<th>第四个（k&#x3D;4）</th>
<th>第五个（k&#x3D;3）</th>
<th>第五个（k&#x3D;2）</th>
<th>第五个（k&#x3D;1）</th>
<th>第六个（k&#x3D;1）</th>
<th>第七个（k&#x3D;1）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td align="left"></td>
<td>6</td>
<td><del>6</del>    （1小于6，6出栈）</td>
<td></td>
<td></td>
<td></td>
<td>8</td>
</tr>
<tr>
<td></td>
<td></td>
<td align="left">5</td>
<td>5</td>
<td>5</td>
<td><del>5</del>  （1小于5，5出栈）</td>
<td></td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>4</td>
<td align="left">4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td><del>4</del>  1    （1小于4，4出栈， 1入栈）</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td align="left">1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>k还有额度 则 栈顶的8要出栈</p>
<p>2.出栈</p>
<p>最终结果是112</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">string</span> removeKdigits(<span class="type">string</span> num, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">string</span> result;</span><br><span class="line">        <span class="type">string</span> resultTmp;</span><br><span class="line">        stack&lt;char&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            char c = num[i];</span><br><span class="line">            <span class="comment">// 1.1 栈不为空，并且当前值比栈内值小，并且有剩余移除的额度</span></span><br><span class="line">            while (!st.empty() &amp;&amp; c &lt; st.top() &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 栈为空就入栈；当前值比栈内值大也入栈</span></span><br><span class="line">            st.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有剩余的额度要继续出栈</span></span><br><span class="line">        while (k &gt; <span class="number">0</span> &amp;&amp; !st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 出栈</span></span><br><span class="line">        while (!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            resultTmp += st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(resultTmp.begin(), resultTmp.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!resultTmp.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 栈里有内容删除前面的0</span></span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            while (index &lt; resultTmp.size() &amp;&amp; resultTmp[index] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除前面0的resultTmp</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; resultTmp.size())</span><br><span class="line">            &#123;</span><br><span class="line">                result = resultTmp.substr(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 全是0的resultTmp</span></span><br><span class="line">                resultTmp = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">                result = resultTmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 栈里没内容就是空</span></span><br><span class="line">            resultTmp = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            result = resultTmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><p>go代码里没有stack，需要用切片来实现stack</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Push(str <span class="type">byte</span>) &#123;</span><br><span class="line">	*s = <span class="built_in">append</span>(*s, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Pop() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i := <span class="built_in">len</span>(*s) - <span class="number">1</span></span><br><span class="line">		*s = (*s)[:i]</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> Top() (<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> s.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i := <span class="built_in">len</span>(*s) - <span class="number">1</span></span><br><span class="line">		elenment := (*s)[i]</span><br><span class="line">		<span class="keyword">return</span> elenment, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(*s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseSlice</span><span class="params">(s []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length/<span class="number">2</span>; i++ &#123;</span><br><span class="line">		s[i], s[length<span class="number">-1</span>-i] = s[length<span class="number">-1</span>-i], s[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeKdigits</span><span class="params">(num <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> st Stack</span><br><span class="line">	<span class="keyword">var</span> resultTmp []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="comment">//1.入栈</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">		c := num[i]</span><br><span class="line">		<span class="keyword">for</span> !st.IsEmpty() &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> s, _ := st.Top(); c &lt; s &#123;</span><br><span class="line">				st.Pop()</span><br><span class="line">				k--</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		st.Push(c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k &gt; <span class="number">0</span> &amp;&amp; !st.IsEmpty() &#123;</span><br><span class="line">		st.Pop()</span><br><span class="line">		k--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.出栈</span></span><br><span class="line">	<span class="keyword">for</span> !st.IsEmpty() &#123;</span><br><span class="line">		s, _ := st.Top()</span><br><span class="line">		resultTmp = <span class="built_in">append</span>(resultTmp, s)</span><br><span class="line">		st.Pop()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(resultTmp) != <span class="number">0</span> &#123;</span><br><span class="line">		ReverseSlice(resultTmp)</span><br><span class="line">		index := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> index &lt; <span class="built_in">len</span>(resultTmp) &amp;&amp; resultTmp[index] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> index &lt; <span class="built_in">len</span>(resultTmp) &#123;</span><br><span class="line">			<span class="keyword">for</span> index &lt; <span class="built_in">len</span>(resultTmp) &#123;</span><br><span class="line">				<span class="comment">//函数string()可以将一个byte（或rune）转换为一个包含该字符的字符串</span></span><br><span class="line">				result += <span class="type">string</span>(resultTmp[index])</span><br><span class="line">				index++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h2><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>动态规划题，当前的最小路径依赖于之前路径的最小值+当前格子值</p>
<ul>
<li>状态转移方程 （找dp[ i ] [ j ]  如何得到）</li>
</ul>
<p>dp表示到位置[ i ] [ j ] 的路径最小值</p>
<p>因为路径是从左往右，所以到当前的最小路径是之前最小路径+当前格子值</p>
<p>其中之前最小路径是min(dp[ i ] [ j -1 ], dp[ i - 1 ] [ j ])</p>
<p>即dp[ i ] [ j ]  &#x3D; min(dp[ i ] [ j -1 ], dp[ i - 1 ] [ j ]) + grid[ i ] [ j ] </p>
<ul>
<li>初始值</li>
</ul>
<p>第0行第0列的值为格子自身</p>
<p>第0行 第 1 列 ~ 第 j 列 的值都是前一个路径值和+自身格子值 即 dp[ 0 ] [ j - 1] + grid[ 0 ] [ j ]  &#x3D;  dp[ 0 ] [ j ]</p>
<p>第0列 第 1 行 ~ 第 j 行 的值都是前一个路径值和+自身格子值 即 dp[ i - 1 ] [ 0 ] + grid[ i ] [ 0 ] &#x3D; dp[ i ] [ 0 ]</p>
<table>
<thead>
<tr>
<th></th>
<th>第 0 列</th>
<th>第 … 列</th>
<th>第 j-1 列</th>
<th>第 j 列</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第 0 行</strong></td>
<td><em>grid[ 0 ] [ 0 ] &#x3D; dp [ 0 ] [ 0 ]</em></td>
<td></td>
<td><em>grid[ 0 ] [ j-1 ] + dp [ 0 ] [ j-2 ]</em></td>
<td><em>grid[ 0 ] [ j ] + dp [ 0 ] [ j-1 ]</em></td>
<td></td>
</tr>
<tr>
<td><strong>第 … 行</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>第 i-1 行</strong></td>
<td><em>grid[ i-1 ] [ 0 ] + dp [ i-2] [ 0 ]</em></td>
<td></td>
<td></td>
<td>grid[ i - 1 ] [ j ] （dp[ i - 1 ] [ j ]）</td>
<td></td>
</tr>
<tr>
<td><strong>第 i 行</strong></td>
<td><em>grid[ i ] [ 0 ] &#x3D; dp [ i-1] [ 0 ]</em></td>
<td></td>
<td>grid[ i ] [ j -1 ] （dp[ i ] [ j -1 ]）</td>
<td>grid[ i ] [ j ] （dp[ i ] [ j ]）</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 1.初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 1.1 第0列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2 第0行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h5><p>错误：var dp [m][n]int<br>数组长度必须是一个常量 编译时就要确定</p>
<p>需要一个动态大小的二维结构，使用make创建和初始化一个二维切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	m := <span class="built_in">len</span>(grid)</span><br><span class="line">	n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//错误：var dp [m][n]int</span></span><br><span class="line">	<span class="comment">//数组长度必须是一个常量 编译时就要确定</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.初始化</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.状态转移</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			dp[i][j] = Min(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + grid[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用go搭建一个pipeline</title>
    <url>/pipeline/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li>service需要从q里拿到attachment</li>
<li>并且需要对attachment进行解压缩，对于合法的文件提取文件的文本内容，并重新组织。</li>
<li>并将attachment存储到s3上，同时将合法的文件内容传输给下一个service处理</li>
</ol>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>按照上述的任务，如果串行执行，每一步任务必须要等上一步任务完成才能开始执行。</p>
<p>如果有一个任务执行时间较长，那就会影响效率。</p>
<h3 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h3><p>为了提升效率，采用pipeline执行多任务，当每个任务的处理时间相近时，效率可提高n-1&#x2F;n（n为任务数）</p>
<ul>
<li><p><strong>pipeline</strong>: 采用<strong>goroutine + channel</strong>方式， 实现了<strong>生产者消费者模型</strong></p>
<p>每个任务是一个goroutine，将经过当前任务处理好的数据放入channel中传递给下一个任务</p>
<p>因此，有需要处理时才有数据，可以减少内存使用，同时多个goroutine并行处理，充分利用资源</p>
</li>
<li><p>每个任务封装到单独函数中，实现模块化设计，代码也会更清晰</p>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>初始化</p>
<ul>
<li>数据库</li>
<li>消息队列</li>
</ul>
</li>
<li><p>实现pipeline</p>
<ul>
<li><p>f1函数（func receive)</p>
<ul>
<li>创建out channel</li>
<li>起一个goroutine循环去处理<ul>
<li>去q里拿attachment, 把拿到的attachment放入out channel中</li>
<li>sleep 一定时间，继续去q里拿下一个</li>
</ul>
</li>
<li>返回out channel</li>
</ul>
</li>
<li><p>f2函数（func process), 接收f1函数的channel为自己的in channel</p>
<ul>
<li><p>创建out channel</p>
</li>
<li><p>起一个goroutine循环去处理</p>
<p>去in channel里拿task, 把处理后的task放入out channel中</p>
</li>
<li><p>返回out channel</p>
</li>
</ul>
</li>
<li><p>f3函数（func upload), 接收f2函数的channel为自己的in channel</p>
<p>利用main函数的主线程来调用f3函数，使得函数阻塞在f3这里</p>
<ul>
<li><p>循环去处理</p>
<p>去in channel里拿task, 处理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>伪代码</p>
<p>main.go代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">out1 := f1()</span><br><span class="line">out2 := f2(out1)</span><br><span class="line">f3(out2)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中：</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
f1去q里拿attchment放入channel中</p>
</li>
<li><p><input disabled="" type="checkbox"> 
当channel中有内容时，f2进行处理，处理完后放入channel</p>
</li>
<li><p><input disabled="" type="checkbox"> 
当channel中有内容时，f3进行处理</p>
</li>
</ul>
<p>f1, f2中都会单独起一个goroutine处理，f3则是利用main函数的主线程来调用f3函数，使得函数阻塞在f3这里</p>
<p>如果f3也起一个goroutine, 那么函数就会立即结束</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/images/pipeline1.png"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="graceful-shutdown"><a href="#graceful-shutdown" class="headerlink" title="graceful shutdown"></a>graceful shutdown</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果f1, f2, f3有一个任务在处理时， service突然退出了，那需要把当前任务做完，即需要把f1-&gt;f2-&gt;f3这一套流程走完</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>创建一个done channel用于广播结束信号</li>
<li>创建一个ch channel, 监听几个退出信号(syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</li>
<li>起一个goroutine等待ch channel内容，当ch channel里有内容时<ul>
<li>关闭done channel: 相当于向channel里发送零值，等同于广播</li>
</ul>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//start for graceful down</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-ch</span><br><span class="line">	<span class="comment">//广播done信号</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	log.Infof(MainTraceId, <span class="string">&quot;Shutdown Server...&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//end for graceful down</span></span><br></pre></td></tr></table></figure>

<h6 id="f1函数"><a href="#f1函数" class="headerlink" title="f1函数"></a>f1函数</h6><p>如果done channel里有数据，就直接返回，不再去q里取attachment了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> Task)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-done:<span class="comment">//graceful shutdown</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			out &lt;- Task&#123;</span><br><span class="line">				Num:   i,</span><br><span class="line">				QName: qName,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<h6 id="f2函数"><a href="#f2函数" class="headerlink" title="f2函数"></a>f2函数</h6><p>f2函数不用处理，因为当f1传来的channel没有内容，f2就不会再处理了</p>
<h6 id="f3函数"><a href="#f3函数" class="headerlink" title="f3函数"></a>f3函数</h6><p>f3函数如果f2传来的channel里没有内容，并且done channel里有内容的时候，才会结束f3，此时相当于流水线的任务都完成了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> task := <span class="keyword">range</span> in &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s:%d\n&quot;</span>, task.QName, task.Num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//graceful shutdown</span></span><br><span class="line">&lt;-done</span><br></pre></td></tr></table></figure>



<h4 id="多个q如何处理"><a href="#多个q如何处理" class="headerlink" title="多个q如何处理"></a>多个q如何处理</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>如果f1需要去多个q里取attachment, 则需要将多个channel里的内容合并到一个channel里</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><ol>
<li>创建out channel</li>
<li>遍历多个channels<ul>
<li>将多个channel的内容都加入到out channel中</li>
<li>这里channel加入的数据是不需要顺序的，因此可以使用新的goroutine来专门把内容加入outchannel</li>
</ul>
</li>
<li>等待merge完成并关闭out channel<ul>
<li>由于需要等所有channel里的内容加入到out channel，所以需要同步等完成</li>
<li>但是同步时不能阻塞主程序，因此需要新开一个goroutine去等待</li>
</ul>
</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(chs ...&lt;-<span class="keyword">chan</span> Task)</span></span> &lt;-<span class="keyword">chan</span> Task &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> Task)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chs))</span><br><span class="line"></span><br><span class="line">	output := <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;-<span class="keyword">chan</span> Task)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> task := <span class="keyword">range</span> ch &#123;</span><br><span class="line">			out &lt;- task</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		<span class="keyword">go</span> output(ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//同步时不能阻塞主程序，因此需要新开一个goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;monitor-service/internal/log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MainTraceId = <span class="string">&quot;main&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">	Num   <span class="type">int</span></span><br><span class="line">	QName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//start init</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//end init</span></span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//start for graceful down</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br><span class="line">	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		<span class="comment">//广播done信号</span></span><br><span class="line">		<span class="built_in">close</span>(done)</span><br><span class="line">		log.Infof(MainTraceId, <span class="string">&quot;Shutdown Server...&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//end for graceful down</span></span><br><span class="line"></span><br><span class="line">	upload(done, process(merge(receive(done, <span class="string">&quot;main queue&quot;</span>), receive(done, <span class="string">&quot;dlq queue&quot;</span>))))</span><br><span class="line"></span><br><span class="line">	log.Infof(MainTraceId, <span class="string">&quot;Server Exit!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(chs ...&lt;-<span class="keyword">chan</span> Task)</span></span> &lt;-<span class="keyword">chan</span> Task &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> Task)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chs))</span><br><span class="line"></span><br><span class="line">	output := <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;-<span class="keyword">chan</span> Task)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> task := <span class="keyword">range</span> ch &#123;</span><br><span class="line">			out &lt;- task</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">		<span class="keyword">go</span> output(ch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//同步时不能阻塞主程序，因此需要新开一个go routine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, qName <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Task &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> Task)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				out &lt;- Task&#123;</span><br><span class="line">					Num:   i,</span><br><span class="line">					QName: qName,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(in &lt;-<span class="keyword">chan</span> Task)</span></span> &lt;-<span class="keyword">chan</span> Task &#123;</span><br><span class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> Task)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> task := <span class="keyword">range</span> in &#123;</span><br><span class="line">			out &lt;- task</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(out)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, in &lt;-<span class="keyword">chan</span> Task)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> task := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s:%d\n&quot;</span>, task.QName, task.Num)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>运行后发现分别从main queue和dlq queue里拉数据，当输入停止service信号（ctrl+c)时，程序graceful shutdown正常结束</p>
</blockquote>
<p>docker run -p 8081:80 –rm monitor-parser<br>main queue:1<br>dlq queue:1<br>main queue:2<br>main queue:3<br>dlq queue:2<br>main queue:4<br>main queue:5<br>dlq queue:3<br>dlq queue:4<br>main queue:6<br>main queue:7<br>dlq queue:5<br>dlq queue:6<br>main queue:8<br>main queue:9<br>dlq queue:7<br>dlq queue:8<br>main queue:10<br>dlq queue:9<br>dlq queue:10<br>^C[2023&#x2F;12&#x2F;05 08.56.17.245260,,Infof,main]parser.go:39, Shutdown Server…<br>[2023&#x2F;12&#x2F;05 08.56.17.245325,,Infof,main]parser.go:45, Server Exit!</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用go搭建一个http server</title>
    <url>/httpServer/</url>
    <content><![CDATA[<h1 id="如何使用go搭建一个http-server"><a href="#如何使用go搭建一个http-server" class="headerlink" title="如何使用go搭建一个http server"></a>如何使用go搭建一个http server</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>需要有一个service去接收client端传来的attachment，并进行处理</p>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol>
<li><p>client端需要等待service接收attachment并处理后的response</p>
<p>处理过程可能耗时</p>
</li>
<li><p>前端也会有upload接口来上传文件，client端不止一个</p>
</li>
</ol>
<h3 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h3><p>基于要求2，需要有http请求，如果让client端直接将attchment塞入q, client端需要有能力与队列交互，并处理与队列相关的错误与异常，还要考虑只有合法客户端才能发布消息到队列。</p>
<p>由于此处的client端不止一个，因此维护多个client端与队列通信较为复杂且不容易维护。</p>
<p>因此这里采用的方法是：</p>
<p>clinet端直接与service端交互，service端接收client端的http请求后，将attachment塞入q中，然后立即给client端返回200，节省等待处理的过程。</p>
<p>client只需要关注如何把attachment发送给service端，无需知道队列的存在，与队列的操作都由service端负责，能更好的控制和优化与队列的操作</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>初始化</p>
<ul>
<li>数据库</li>
<li>消息队列</li>
<li>主contenxt（用于监听结束信号）</li>
</ul>
</li>
<li><p>启动http server</p>
<ul>
<li><p>创建gin实例</p>
</li>
<li><p>向gin实例添加中间件：日志记录器，恢复中间件，Prometheus请求指标处理器</p>
</li>
<li><p>注册pprof调试路由：可查看调试信息</p>
</li>
<li><p>设置get, post等方法的处理函数 </p>
<p>或者创建新的路由组下的处理函数</p>
</li>
<li><p>创建http实例， 设置读写，连接超时时间，并将上面创建的gin实例传入handler中，handler是服务器对于http请求的处理方式</p>
</li>
<li><p>用新gouroutine启动http服务器，因为监听http请求的ListenAndServe方法是阻塞操作，不希望阻塞主程序</p>
</li>
</ul>
</li>
<li><p>当有终止信号时，graceful shutdown</p>
<p>新创建一个context，一定时间后结束（10s），在这时间内还能继续接收请求</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;monitor-service/internal/config&quot;</span></span><br><span class="line">	<span class="string">&quot;monitor-service/internal/log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-contrib/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MainTraceId = <span class="string">&quot;main&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">()</span></span> *http.Server &#123;</span><br><span class="line">	gin.SetMode(gin.DebugMode)</span><br><span class="line"></span><br><span class="line">	router := gin.New()</span><br><span class="line">	router.Use(gin.Logger(), gin.Recovery())</span><br><span class="line"></span><br><span class="line">	pprof.Register(router)</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/&quot;</span>, welcome)</span><br><span class="line"></span><br><span class="line">	v1Root := router.Group(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">	monitorRoot := v1Root.Group(<span class="string">&quot;monitor&quot;</span>)</span><br><span class="line">	monitorRoot.POST(<span class="string">&quot;/upload&quot;</span>, upload)</span><br><span class="line"></span><br><span class="line">	srv := http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">&quot;:80&quot;</span>,</span><br><span class="line">		Handler:      http.TimeoutHandler(router, <span class="number">10</span>*time.Second, <span class="string">`&#123;&quot;error&quot;: &quot;Handler timeout&quot;&#125;`</span>),</span><br><span class="line">		ReadTimeout:  <span class="number">10</span> * time.Second,</span><br><span class="line">		WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//主动关闭连接不算err</span></span><br><span class="line">		<span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">			log.Errf(MainTraceId, <span class="string">&quot;Server Listen:%s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;srv</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Infof(MainTraceId, <span class="string">&quot;%s: start main&quot;</span>, config.GetAppName())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//start init</span></span><br><span class="line">	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line">	<span class="keyword">defer</span> stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//end init</span></span><br><span class="line"></span><br><span class="line">	srv := serve()</span><br><span class="line"></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	stop()</span><br><span class="line">	log.Info(MainTraceId, <span class="string">&quot;Shutdown Server....&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//graceful shutdown</span></span><br><span class="line">	ctx, cancle := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancle()</span><br><span class="line">	<span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errf(MainTraceId, <span class="string">&quot;Server Shutdown:%s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Info(MainTraceId, <span class="string">&quot;Server Exit!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>handler.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;result&quot;</span>: <span class="string">&quot;pong&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">//<span class="doctag">TODO:</span> get file</span></span><br><span class="line">	c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;OK&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">BUILDNO=10000</span><br><span class="line">BUILD_TIME:=<span class="variable">$(<span class="built_in">shell</span> date)</span></span><br><span class="line">APPNAMESERVER=server</span><br><span class="line"></span><br><span class="line">DIR_CUR := <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(<span class="built_in">firstword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>))</span><br><span class="line">DOCKERDIR=<span class="variable">$(DIR_CUR)</span>/docker</span><br><span class="line">OUTPUTBINSERVER=<span class="variable">$(DOCKERDIR)</span>/server/<span class="variable">$(APPNAMESERVER)</span></span><br><span class="line"></span><br><span class="line">GOOS=linux</span><br><span class="line">GOARCH=amd64</span><br><span class="line">GO=go</span><br><span class="line">GOARGS_LD_FLAGS=-X <span class="string">&quot;main.BuildNumber=<span class="variable">$(BUILDNO)</span>&quot;</span> -X <span class="string">&quot;main.BuildTime=<span class="variable">$(BUILD_TIME)</span>&quot;</span></span><br><span class="line">GOARGS_BUILD_SERVER=build -v -o <span class="variable">$(OUTPUTBINSERVER)</span> -ldflags &#x27;<span class="variable">$(GOARGS_LD_FLAGS)</span>&#x27;</span><br><span class="line">GOVER=<span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(GO)</span> version)</span></span><br><span class="line"></span><br><span class="line">BUILDER_IMAGE=golang</span><br><span class="line">BUILDER_TAG=1.12</span><br><span class="line"></span><br><span class="line"><span class="section">all: build</span></span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">	@echo <span class="string">&quot;===&gt; Build <span class="variable">$(APPNAMESERVER)</span> with <span class="variable">$(GOVER)</span>&quot;</span></span><br><span class="line">	(cd src; CGO_ENABLED=0 GOOS=<span class="variable">$(GOOS)</span> GOARCH=<span class="variable">$(GOARCH)</span> <span class="variable">$(GO)</span> <span class="variable">$(GOARGS_BUILD_SERVER)</span> monitor-service/cmd/server)</span><br><span class="line"></span><br><span class="line"><span class="section">docker: build</span></span><br><span class="line">	docker build -f docker/server/Dockerfile ./docker/server -t monitor-service:latest</span><br><span class="line"></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">	docker run -p 8080:80 --rm monitor-service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OUTPUTBINSERVER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean build test run docker</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> amazonlinux:<span class="number">2023</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum update -y &amp;&amp; yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> server /</span></span><br><span class="line"><span class="keyword">ENV</span> LOGLEVEL=DEBUG</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/server&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul>
<li>make docker<ol>
<li>执行go build</li>
<li>docker build -f docker&#x2F;server&#x2F;Dockerfile .&#x2F;docker&#x2F;server -t monitor-service:latest</li>
</ol>
</li>
<li>make run<ul>
<li>执行docker run -p 8080:80 –rm monitor-service</li>
</ul>
</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="自定义日志生成器"><a href="#自定义日志生成器" class="headerlink" title="自定义日志生成器"></a>自定义日志生成器</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>格式化log输出为：<u>[时间 app名字 log级别名称 id]文件名:行数, log内容</u></p>
<p>[2023&#x2F;12&#x2F;05 06.01.32.576361,,Infof,main]server.go:53, monitor: start main</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ul>
<li><p>按照log级别设置自定义的log</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	LogLevelErr LogLevel = <span class="literal">iota</span></span><br><span class="line">	LogLevelWarn</span><br><span class="line">	LogLevelInfo</span><br><span class="line">	LogLevelDebug</span><br><span class="line"></span><br><span class="line">	defaultLogLevel = LogLevelDebug</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logLevelName = <span class="keyword">map</span>[LogLevel]<span class="type">string</span>&#123;</span><br><span class="line">	LogLevelErr:   <span class="string">&quot;Errf&quot;</span>,</span><br><span class="line">	LogLevelWarn:  <span class="string">&quot;Warnf&quot;</span>,</span><br><span class="line">	LogLevelInfo:  <span class="string">&quot;Infof&quot;</span>,</span><br><span class="line">	LogLevelDebug: <span class="string">&quot;Debugf&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>当是对应的log级别就调用统一的output log函数</p>
<p>根据format的log为： <u>[时间 app名字 log级别名称 id]文件名:行数, log内容</u></p>
<p>其中</p>
<ol>
<li><p>时间：time.Now().UTC().Format(timeFormat)</p>
</li>
<li><p>app名字 log级别名称 id 以及log内容都可以通过调用时候参数传入</p>
</li>
<li><p>file, line需要通过runtime.Caller(skip)找到调用栈,skip表示跳过多少层，返回那层信息</p>
<p>skip&#x3D;0表示caller自己, skip&#x3D;1可以直到调用者，由于这里会多调用了一层output（skip&#x3D;1是得到output信息），要找到调用output函数的信息，skip需要等于2</p>
<ul>
<li>如果 <code>skip</code> 为 0，则获取当前函数（即 Caller 所在函数）的信息；</li>
<li>如果 <code>skip</code> 为 1，则获取调用当前函数的函数的信息；</li>
<li>如果 <code>skip</code> 为 2，则获取调用上述函数的函数的信息，依此类推。</li>
</ul>
</li>
<li><p>最终通过fmt.Sprintf将format内容组织起来，通过os.Stdout.Write输出到标准输出上</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> output(level LogLevel, traceId, log <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">//找出是谁调用了output(在调用栈上移动的步数), skip=0表示caller自己</span></span><br><span class="line">	skip := <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> l == instance &#123;</span><br><span class="line">		skip++</span><br><span class="line">	&#125;</span><br><span class="line">	_, file, line, ok := runtime.Caller(skip)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		file = filepath.Base(file)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := fmt.Sprintf(logFormat, time.Now().UTC().Format(timeFormat), l.serviceName, logLevelName[level], traceId, file, line, log)</span><br><span class="line">	<span class="keyword">if</span> s[<span class="built_in">len</span>(s)<span class="number">-1</span>] != <span class="string">&#x27;\n&#x27;</span> &#123;</span><br><span class="line">		s = s + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将log写到标准输出</span></span><br><span class="line">	_, err := os.Stdout.Write([]<span class="type">byte</span>(s))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">&quot;Write log error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>docker run -p 8080:80 –rm monitor-service<br>[2023&#x2F;12&#x2F;05 06.01.32.576361,,Infof,main]server.go:53, monitor: start main</p>
<h4 id="自定义gin-log日志生成器"><a href="#自定义gin-log日志生成器" class="headerlink" title="自定义gin log日志生成器"></a>自定义gin log日志生成器</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>gin默认的log生成的日志如下</p>
<p>[GIN] 2023&#x2F;12&#x2F;05 - 06:19:06 | 200 |        47.2µs |      172.17.0.1 | POST     “&#x2F;demo&#x2F;monitor&#x2F;upload”</p>
<h5 id="gin-Logger-源码"><a href="#gin-Logger-源码" class="headerlink" title="gin.Logger()源码"></a>gin.Logger()源码</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Start timer</span></span><br><span class="line">		start := time.Now()</span><br><span class="line">		path := c.Request.URL.Path</span><br><span class="line">		raw := c.Request.URL.RawQuery</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process request</span></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Log only when path is not being skipped</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := skip[path]; !ok &#123;</span><br><span class="line">			param := LogFormatterParams&#123;</span><br><span class="line">				Request: c.Request,</span><br><span class="line">				isTerm:  isTerm,</span><br><span class="line">				Keys:    c.Keys,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Stop timer</span></span><br><span class="line">			param.TimeStamp = time.Now()</span><br><span class="line">			param.Latency = param.TimeStamp.Sub(start)</span><br><span class="line"></span><br><span class="line">			param.ClientIP = c.ClientIP()</span><br><span class="line">			param.Method = c.Request.Method</span><br><span class="line">			param.StatusCode = c.Writer.Status()</span><br><span class="line">			param.ErrorMessage = c.Errors.ByType(ErrorTypePrivate).String()</span><br><span class="line"></span><br><span class="line">			param.BodySize = c.Writer.Size()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> raw != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				path = path + <span class="string">&quot;?&quot;</span> + raw</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			param.Path = path</span><br><span class="line"></span><br><span class="line">			fmt.Fprint(out, formatter(param))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h5><p>按照gin.Logger()源码，使用gin.LogFormatterParams和自定义的log生成器，将http请求的log内容按照<u>客户端ip  请求方法 请求路径 请求协议版本 服务端返回给客户端状态码 处理请求时间 user-agent请求头字段内容 错误信息</u>格式组织</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GinLogger</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		path := c.Request.URL.Path</span><br><span class="line">		raw := c.Request.URL.RawQuery</span><br><span class="line"></span><br><span class="line">		<span class="comment">//处理下一个中间件请求</span></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		param := gin.LogFormatterParams&#123;</span><br><span class="line">			Request: c.Request,</span><br><span class="line">			Keys:    c.Keys,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> raw != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			path = path + <span class="string">&quot;?&quot;</span> + raw</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		param.ClientIP = c.ClientIP()</span><br><span class="line">		param.Method = c.Request.Method</span><br><span class="line">		param.Path = path</span><br><span class="line">		<span class="comment">// param.Request.Proto = c.Request.Proto</span></span><br><span class="line">		param.StatusCode = c.Writer.Status()</span><br><span class="line">		param.TimeStamp = time.Now()</span><br><span class="line">		param.Latency = param.TimeStamp.Sub(start)</span><br><span class="line">		param.ErrorMessage = c.Errors.ByType(gin.ErrorTypePrivate).String()</span><br><span class="line">		<span class="comment">// param.BodySize = c.Writer.Size()</span></span><br><span class="line"></span><br><span class="line">		log.Infof(<span class="string">&quot;gin-logger&quot;</span>, <span class="string">&quot;%s %s %s %s %d %s \&quot;%s\&quot; %s&quot;</span>, param.ClientIP, param.Method, param.Path, param.Request.Proto, param.StatusCode, param.Latency, param.Request.UserAgent(), param.ErrorMessage)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><p>format后的gin log如下: </p>
<ul>
<li>按照<u>[时间 app名字 log级别名称 id]文件名:行数, log内容</u><ul>
<li>log内容按照 <u>客户端ip  请求方法 请求路径 请求协议版本 服务端返回给客户端状态码 处理请求时间 user-agent请求头字段内容 错误信息</u></li>
</ul>
</li>
</ul>
<p>[2023&#x2F;12&#x2F;05 06.00.43.075511,,Infof,gin-logger]middleware.go:38, 172.17.0.1 GET &#x2F; HTTP&#x2F;1.1 200 51.3µs “curl&#x2F;7.68.0”<br>[2023&#x2F;12&#x2F;05 06.00.47.551118,,Infof,gin-logger]middleware.go:38, 172.17.0.1 POST &#x2F;demo&#x2F;monitor&#x2F;upload HTTP&#x2F;1.1 200 35.9µs “curl&#x2F;7.68.0”</p>
<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><ul>
<li>测试命令：curl -X GET localhost:8080&#x2F;</li>
</ul>
<p>显示：{“result”:”pong”}</p>
<ul>
<li>curl -X POST localhost:8080&#x2F;demo&#x2F;monitor&#x2F;upload -H ‘X-Trace-Id: 123’ -F ‘file&#x3D;@”test.txt”‘</li>
</ul>
<p>显示：{“code”:”200”,”message”:”OK”}</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用go搭建一个定时任务</title>
    <url>/cronjob/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>问题描述：</p>
<ol>
<li>需要有一个定时任务去dns上查询用户的配置信息</li>
<li>查询完成后需要保存到db中让ui来显示</li>
</ol>
</li>
<li><p>使用定时任务处理实时性没有很高的任务</p>
<p>原因： dns的传播时间为几分钟到72小时，所以查询dns的配置对实时性要求不高，可以使用定时任务</p>
</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.初始化数据库以及配置文件参数等</p>
<p>2.启动自动更新</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>设置deploy.yml中的schedule为一小时更新一次</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 */1 * * *&quot;</span></span><br><span class="line"> <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">259200</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">xxx:&lt;IMAGE_TAG&gt;</span></span><br><span class="line">              <span class="attr">resources:</span></span><br><span class="line">                <span class="attr">requests:</span></span><br><span class="line">                  <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line">                  <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">                <span class="attr">limits:</span></span><br><span class="line">                  <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">                  <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">              <span class="attr">envFrom:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">xxx-configmap</span></span><br><span class="line">              <span class="attr">env:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REGION</span></span><br><span class="line">                  <span class="attr">valueFrom:</span></span><br><span class="line">                    <span class="attr">configMapKeyRef:</span></span><br><span class="line">                      <span class="attr">name:</span> <span class="string">xxx-configmap</span></span><br><span class="line">                      <span class="attr">key:</span> <span class="string">region</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>



<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/images/cronjob1.png"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>Deploy cron-job.yaml：kubectl apply -f cron-job.yaml</p>
<p>cron job可以自动查询dns并保存到db表中， ui上能显示对应dns的值</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用问题</title>
    <url>/hexoDeploy/</url>
    <content><![CDATA[<h2 id="多用户合作部署博客网站"><a href="#多用户合作部署博客网站" class="headerlink" title="多用户合作部署博客网站"></a>多用户合作部署博客网站</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>hexo d的时候多用户会存在覆盖commit的情况</li>
</ul>
<p>但是如果同时维护博客网站也没有意义， 因为hexo g是把本地生成的markdown文件转成html, hexo d是把保存再public目录下的生成的html相关的文件上传到github上再进行部署，这个github repo只是保存了一些网页资源。</p>
<p>博客的原始的markdown文件以及相关配置才是重要的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>因此，为了能维护博客的源文件，同时在更新博客内容的时候能自动部署网站且不覆盖其他人的commit, 可以利用github action</li>
</ul>
<h4 id="使用ci"><a href="#使用ci" class="headerlink" title="使用ci"></a>使用ci</h4><p>博客网站为repo1：</p>
<p><a href="https://github.com/iamyeswc/iamyeswc.github.io">https://github.com/iamyeswc/iamyeswc.github.io</a></p>
<p>博客源文件为repo2:</p>
<p><a href="https://github.com/iamyeswc/hexo-blog">https://github.com/iamyeswc/hexo-blog</a></p>
<p>当repo1有提交到main分支的时候就自动调用hexo g &amp; hexo d，生成部署文件提交到repo2</p>
<h4 id="ci过程遇到的问题"><a href="#ci过程遇到的问题" class="headerlink" title="ci过程遇到的问题"></a>ci过程遇到的问题</h4><ul>
<li><p>每次都调用hexo g完成后直接hexo d，导致每次都是会创建新的commit提交而不是在原始repo2的基础上commit 追加新commit</p>
</li>
<li><p>因此， ci过程：</p>
<p>(在repo1的.github&#x2F;workflows&#x2F;下面创建hexo-deploy.yml文件)</p>
<ol>
<li><p>checkout repo1</p>
</li>
<li><p>安装必要的依赖：node.js, hexo-cli, npm</p>
</li>
<li><p>build目标文件</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
导入部署密钥， 使用ssh-keygen生成的私钥保存到repo1的secret中，用于验证部署的身份</p>
<p><img src="/images/hexoCi1.png"></p>
</li>
<li><p><input disabled="" type="checkbox"> 
调用hexo clean &amp; hexo g生成目标部署文件</p>
<p>hexo的行为是： 部署的文件都存在public目录下</p>
</li>
</ul>
</li>
<li><p>checkout repo2</p>
</li>
<li><p>部署到repo2</p>
<ul>
<li><input disabled="" type="checkbox"> 把public下的所有文件都拷贝到repo2下</li>
<li><input disabled="" type="checkbox"> 如果有改动就提交到repo2的main分支</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># 当main分支有新的推送时执行此工作流</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span> <span class="comment"># 允许手动触发此工作流</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">hexo-blog</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">14</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">deploy</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span> <span class="comment"># 使用你的部署密钥</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name &#x27;iamyeswc&#x27;</span></span><br><span class="line"><span class="string">          git config --global user.email &#x27;iamyeswc@163.com&#x27;</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo g</span></span><br><span class="line"><span class="string">          ls -al public</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">iamyeswc.github.io</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">iamyeswc/iamyeswc.github.io</span></span><br><span class="line">          <span class="attr">ssh-key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">./iamyeswc.github.io</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">iamyeswc.github.io</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cp -R public/* ./iamyeswc.github.io/</span></span><br><span class="line"><span class="string">          cd iamyeswc.github.io</span></span><br><span class="line"><span class="string">          if [ -n &quot;$(git status --porcelain)&quot; ]; then</span></span><br><span class="line"><span class="string">            git add .</span></span><br><span class="line"><span class="string">            git commit -m &quot;Site updated: $(date +&quot;%Y-%m-%d %H:%M:%S&quot;)&quot;</span></span><br><span class="line"><span class="string">            git push origin HEAD:main</span></span><br><span class="line"><span class="string">          else </span></span><br><span class="line"><span class="string">            echo &quot;No changes to commit&quot;</span></span><br><span class="line"><span class="string">          fi</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>repo1能够成功ci:</p>
<p><img src="/images/hexoCi2.png"></p>
<p>repo2能够成功部署：</p>
<p><img src="/images/hexoCi3.png"></p>
<h2 id="如何把本地的markdown转成hexo-new后的文件"><a href="#如何把本地的markdown转成hexo-new后的文件" class="headerlink" title="如何把本地的markdown转成hexo new后的文件"></a>如何把本地的markdown转成hexo new后的文件</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>hexo new后的文件有title, tags, categories,date 等信息，</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo使用问题</span><br><span class="line">tags: hexo</span><br><span class="line">categories: github action</span><br><span class="line">abbrlink: 14698</span><br><span class="line"><span class="section">date: 2023-12-01 10:04:11</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是本地编写的markdown笔记并没有这些内容，因此写了脚本将本地的md笔记批量导入到hexo post目录下：</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>输入old path: markdown笔记路径</p>
</li>
<li><p>输入new path: hexo post目录（hexo-blog&#x2F;source&#x2F;_posts）</p>
</li>
<li><p>遍历old path下的所有markdown文件</p>
<ul>
<li><p>每个文件需要提示输入categories和tags</p>
</li>
<li><p>获取旧文件的作为新文件的title</p>
</li>
<li><p>获取旧文件的修改日期作为新文件的date</p>
<p>(格式%Y-%m-%d %H:%M:%S)</p>
</li>
<li><p>把上面的内容输入到新文件中， 并把旧文件的markdown内容追加进去</p>
</li>
</ul>
</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求用户输入旧的路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please enter the old path:&quot;</span></span><br><span class="line"><span class="built_in">read</span> folder_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求用户输入新的路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please enter the new path:&quot;</span></span><br><span class="line"><span class="built_in">read</span> output_folder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件夹下的所有Markdown文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$folder_path</span>&quot;</span>/*.md</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 获取文件名 (不包含扩展名)</span></span><br><span class="line">    filename=$(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> .md)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Please enter categories for <span class="variable">$filename</span>:&quot;</span></span><br><span class="line">    <span class="built_in">read</span> categories</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Please enter tags for <span class="variable">$filename</span>:&quot;</span></span><br><span class="line">    <span class="built_in">read</span> tags</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文件的最后修改日期和时间（不包含小数秒）</span></span><br><span class="line">    last_modified=$(<span class="built_in">date</span> -d @$(<span class="built_in">stat</span> -c %Y <span class="string">&quot;<span class="variable">$file</span>&quot;</span>) +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 读取文件中的第一个标题 (# 开头的文字)</span></span><br><span class="line">    title=$(grep -m 1 <span class="string">&#x27;^# &#x27;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> | sed <span class="string">&#x27;s/^# //&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新的文件，内容按照指定格式编写</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;---&quot;</span> &gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;title: <span class="variable">$filename</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;tags: <span class="variable">$tags</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;categories: <span class="variable">$categories</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;date: <span class="variable">$last_modified</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;---&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 追加原始文件的内容到新文件中</span></span><br><span class="line">    <span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$output_folder</span>/<span class="variable">$filename</span>.md&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>hexo-blog&#x2F;source&#x2F;_posts目录下有对应的文件</p>
]]></content>
      <categories>
        <category>github action</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pprof对go http service进行性能分析</title>
    <url>/pprof/</url>
    <content><![CDATA[<h2 id="代码应用"><a href="#代码应用" class="headerlink" title="代码应用"></a>代码应用</h2><p><strong>参考</strong>：<a href="https://github.com/gin-contrib/pprof">https://github.com/gin-contrib/pprof</a></p>
<p>把pprof挂载到gin的路由器下有两种方法</p>
<ul>
<li>在gin的<code>跟路由</code>上注册pprof的路由<br>使用<code>pprof.Register(router)</code><br>下面创建的服务器的路由是<a href="http://localhost/ui/test/">http://localhost:80/ui/test/</a>…<br>则可以通过<a href="http://localhost/debug/pprof/%E6%9D%A5%E8%AE%BF%E9%97%AEpprof%E9%A6%96%E9%A1%B5">http://localhost:80/debug/pprof/来访问pprof首页</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router := gin.New()</span><br><span class="line">router.Use(mw.GinLogger(), gin.Recovery(), mw.PromRequestMetricHandler())</span><br><span class="line">pprof.Register(router)</span><br><span class="line">uiRoot := router.Group(&quot;ui&quot;)</span><br><span class="line">testRoot := uiRoot.Group(&quot;test&quot;)</span><br><span class="line">testRoot .POST(&quot;ruareport&quot;, upload)</span><br><span class="line">testRoot .GET(&quot;healthy&quot;, checkHealthy)</span><br><span class="line"></span><br><span class="line">srv := http.Server&#123;</span><br><span class="line">Addr:         &quot;:80&quot;,</span><br><span class="line">Handler:      http.TimeoutHandler(router, conf.GetConnTimeout(), `&#123;&quot;error&quot;: &quot;Handler Timeout.&quot;&#125;`),</span><br><span class="line">ReadTimeout:  10 * time.Second,</span><br><span class="line">WriteTimeout: conf.GetConnTimeout(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在gin的<code>指定路由</code>上注册pprof的路由<br>使用<code>pprof.Register(router)</code><br>下面创建的服务器的路由是<a href="http://localhost/ui/test/">http://localhost:80/ui/test/</a>…, pprof的路由挂载在了test路由下<br>则需要通过<a href="http://localhost/test/debug/pprof/%E6%9D%A5%E8%AE%BF%E9%97%AEpprof%E9%A6%96%E9%A1%B5">http://localhost:80/test/debug/pprof/来访问pprof首页</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router := gin.New()</span><br><span class="line">router.Use(mw.GinLogger(), gin.Recovery(), mw.PromRequestMetricHandler())</span><br><span class="line">uiRoot := router.Group(&quot;ui&quot;)</span><br><span class="line">pprof.RouteRegister(v1Root)</span><br><span class="line">testRoot := uiRoot.Group(&quot;test&quot;)</span><br><span class="line">testRoot .POST(&quot;ruareport&quot;, upload)</span><br><span class="line">testRoot .GET(&quot;healthy&quot;, checkHealthy)</span><br><span class="line"></span><br><span class="line">srv := http.Server&#123;</span><br><span class="line">Addr:         &quot;:80&quot;,</span><br><span class="line">Handler:      http.TimeoutHandler(router, conf.GetConnTimeout(), `&#123;&quot;error&quot;: &quot;Handler Timeout.&quot;&#125;`),</span><br><span class="line">ReadTimeout:  10 * time.Second,</span><br><span class="line">WriteTimeout: conf.GetConnTimeout(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pprof的路由：</p>
<p>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;             –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapF.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;cmdline      –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapF.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;profile      –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapF.func1 (4 handlers)<br>[GIN-debug] POST   &#x2F;debug&#x2F;pprof&#x2F;symbol       –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapF.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;symbol       –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapF.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;trace        –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapF.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;allocs       –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapH.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;block        –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapH.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;goroutine    –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapH.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;heap         –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapH.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;mutex        –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapH.func1 (4 handlers)<br>[GIN-debug] GET    &#x2F;debug&#x2F;pprof&#x2F;threadcreate –&gt; github.com&#x2F;gin-gonic&#x2F;gin.WrapH.func1 (4 handlers)</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE版本</title>
    <url>/cveVersion/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>CVE 是 通用漏洞披露 (Common Vulnerabilities and Exposures)的英文缩写，列出了已公开的各种计算机缺陷，每一个CVE包括CVE ID(例如:CVE-2019-1234567”)、安全漏洞的描述和相关参考资料。</p>
<p>Linux kernel包含了很多个发行版本，比如6.x.y,5.x.y,4.x.y,3.x.y等不同分支的发行版本，每个版本发行后都可能会有安全缺陷。现在需要写一个程序来统计某一个特定Linux kernel版本存在哪些安全缺陷(CVE)，并按照严重程度的分数从高到低输出。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入1:Linux kernel的CVE信息，假定每条CVE 信息内容格式如下: CVE ID#CVE Score#影响的版本范围#修复的版本</p>
<p>其中CVE ID格式“CVE-2019-1234567”</p>
<p>假如CVE Score是0到1000的整数<br>影响的版本范围“起始版本-最后版本”<br>修复的版本具体修复的某些版本号，如有多个版本用;隔开</p>
<p>比如:</p>
<p>CVE-2021-3744#55#4.12.0-5.15.0#4.14.249;5.14.10;5.4.141</p>
<p>CVE-2022-4382#64#5.3.0-6.2.0#5.10.165;5.4.230;6.1.8</p>
<p>CVE-2023-0469#56#5.19.0-6.1.5#6.0.11</p>
<p>……</p>
<p>输入2: 需要查询的Linux kernel的版本号。</p>
<p>比如: 6.1.4</p>
<p>输出:要的版本受到影的CVE ID，并按照重程度的分数从高到低排列。</p>
<p>如:CVE-2022-4382,CVE-2023-0469</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>(1)CVE-2021-3744#55#4.12.0-5.15.0#4.14.249;5.14.10;5.4.141</p>
<p>表示CVE ID是CVE-2021-3744，严重程度分数55，受影的kernel版本包含从4.12.0到5.15.0之的所有版本，修复的版本:4.14.249和5.14.10和5.4.141三个版本。</p>
<p>(2)影响的版本范围: 比如4.12.0-5.15.0表示4.12.0和5.15.0版本本身以及两个版本之间的所有版本都受影响，其它的版本则都不受影响。</p>
<p>修复的版本说明: 比如CVE-2021-3744修复的版本4.14.249和5.14.10和5.4.141三个版本，4.14.249表示在4.14分支上，249和249以后的版本都修复了，但是在 4.15&#x2F;5.*&#x2F;6.*等分支上需要看其他的具体修复版本信息。</p>
<p>(3)影响的版本号，修复的版本号，版本号的格式:z.x.y(其中z可能是3&#x2F;4&#x2F;5&#x2F;6,x和y大于等于0的任意整数)。</p>
<p>(4)假定严重程度的分数CVE Score的不会重复。</p>
<p>(5)目前输入1中没有输入完整的Linux kernel的CVE信息，假定每个case输入CVE信息条目数不会超1000，每条信息字符串的长度不会超1000。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.把输入得cve字符串解析到每部分：</p>
<p>Cveid</p>
<p>Cvescore</p>
<p>Kernelversion</p>
<p>Kernelpatchedversion</p>
<p>2.根据输入得版本，遍历上面得cve字符串</p>
<p>需要在影响版本内但是不能在fix 版本之后</p>
<ul>
<li>c++版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;tuple&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using CVE = tuple&lt;string, string, string&gt;;</span><br><span class="line">template &lt;typename Sequence, typename Seperator&gt;</span><br><span class="line">Sequence &amp;split(Sequence &amp;res, const string splitStr, const Seperator sep) &#123;</span><br><span class="line">	istringstream iss(splitStr);</span><br><span class="line">	// 从iss里读数据，读到sep的时候放到s中</span><br><span class="line">	for (string s; getline(iss, s, sep);) &#123;</span><br><span class="line">		typename Sequence::value_type val;</span><br><span class="line">		istringstream isss(s);</span><br><span class="line">		isss &gt;&gt; val;</span><br><span class="line">		// res.insert(res.end(), val);</span><br><span class="line">		res.push_back(val);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">bool inFixed(string fixedVersion, string version) &#123;</span><br><span class="line">	vector&lt;string&gt; fixed;</span><br><span class="line">	split(fixed, fixedVersion, &#x27;;&#x27;);</span><br><span class="line">	vector&lt;int&gt; needCompare;</span><br><span class="line">	split(needCompare, version, &#x27;.&#x27;);</span><br><span class="line">	for (auto fix : fixed) &#123;</span><br><span class="line">		vector&lt;int&gt; tmpFix;</span><br><span class="line">		split(tmpFix, fix, &#x27;.&#x27;);</span><br><span class="line">		if (tmpFix[0] == needCompare[0] &amp;&amp; tmpFix[1] == needCompare[1] &amp;&amp; tmpFix[2] &lt;= needCompare[2]) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">bool inAffected(string affectedVersion, string version) &#123;</span><br><span class="line">	vector&lt;int&gt; start, end, needCompare;</span><br><span class="line">	vector&lt;string&gt; affected;</span><br><span class="line">	split(affected, affectedVersion, &#x27;-&#x27;);</span><br><span class="line">	split(start, affected[0], &#x27;.&#x27;);</span><br><span class="line">	split(end, affected[1], &#x27;.&#x27;);</span><br><span class="line">	split(needCompare, version, &#x27;.&#x27;);</span><br><span class="line">	return start &lt;= needCompare &amp;&amp; needCompare &lt;= end;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; solution(vector&lt;string&gt; str, string version) &#123;</span><br><span class="line">	map&lt;int, CVE&gt; testCVE;</span><br><span class="line">	for (auto s : str) &#123;</span><br><span class="line">		vector&lt;string&gt; item;</span><br><span class="line">		split(item, s, &#x27;#&#x27;);</span><br><span class="line">		string id = item[0];</span><br><span class="line">		int score = stoi(item[1]);</span><br><span class="line">		string ver = item[2];</span><br><span class="line">		string fix = item[3];</span><br><span class="line">		testCVE[score] = make_tuple(id, ver, fix);</span><br><span class="line">	&#125;</span><br><span class="line">	// 反向： rbegin, rend</span><br><span class="line">	// map 有序</span><br><span class="line">	vector&lt;string&gt; res;</span><br><span class="line">	for (auto iter = testCVE.rbegin(); iter != testCVE.rend(); iter++) &#123;</span><br><span class="line">		if (inAffected(get&lt;1&gt;(iter-&gt;second), version) &amp;&amp; !inFixed(get&lt;2&gt;(iter-&gt;second), version)) &#123;</span><br><span class="line">			res.push_back(get&lt;0&gt;(iter-&gt;second));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;string&gt; str = &#123;</span><br><span class="line">		&quot;CVE-2021-3744#55#4.12.0-5.15.0#4.14.249;5.14.10;5.4.141&quot;,</span><br><span class="line">		                          &quot;CVE-2022-4382#64#5.3.0-6.2.0#5.10.165;5.4.230;6.1.8&quot;,</span><br><span class="line">		                          &quot;CVE-2023-0469#56#5.19.0-6.1.5#6.0.11&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br><span class="line">	string testVersion = &quot;6.1.4&quot;;</span><br><span class="line">	vector&lt;string&gt; res = solution(str, testVersion);</span><br><span class="line">	for (auto v : res) &#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>go版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sort&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type CVE struct &#123;</span><br><span class="line">	ID      string</span><br><span class="line">	Score   int</span><br><span class="line">	Version string</span><br><span class="line">	Fix     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func split(splitStr string, sep string) []string &#123;</span><br><span class="line">	return strings.Split(splitStr, string(sep))</span><br><span class="line">&#125;</span><br><span class="line">func solution(testStr []string, testVersion string) []string &#123;</span><br><span class="line">	testCVE := []CVE&#123;&#125;</span><br><span class="line">	for _, val := range testStr &#123;</span><br><span class="line">		datapart := split(val, &quot;#&quot;)</span><br><span class="line">		id := datapart[0]</span><br><span class="line">		score, _ := strconv.Atoi(datapart[1])</span><br><span class="line">		version := datapart[2]</span><br><span class="line">		fix := datapart[3]</span><br><span class="line">		testCVE = append(testCVE, CVE&#123;id, score, version, fix&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(testCVE, func(i, j int) bool &#123;</span><br><span class="line">		return testCVE[i].Score &gt; testCVE[j].Score</span><br><span class="line">	&#125;)</span><br><span class="line">	res := []string&#123;&#125;</span><br><span class="line">	for _, val := range testCVE &#123;</span><br><span class="line">		iter := val</span><br><span class="line">		if inAffected(iter.Version, testVersion) &amp;&amp; !inFixed(iter.Fix, testVersion) &#123;</span><br><span class="line">			res = append(res, iter.ID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br><span class="line">func inFixed(version, testVersion string) bool &#123;</span><br><span class="line">	datapart := split(version, &quot;;&quot;)</span><br><span class="line">	test := split(testVersion, &quot;.&quot;)</span><br><span class="line">	for _, val := range datapart &#123;</span><br><span class="line">		num := val</span><br><span class="line">		numpart := split(num, &quot;.&quot;)</span><br><span class="line">		if numpart[0] == test[0] &amp;&amp; numpart[1] == test[1] &#123;</span><br><span class="line">			tmp1, _ := strconv.Atoi(numpart[2])</span><br><span class="line">			tmp2, _ := strconv.Atoi(test[2])</span><br><span class="line">			if tmp1 &lt;= tmp2 &#123;</span><br><span class="line">				return true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line">func inAffected(version, testVersion string) bool &#123;</span><br><span class="line">	datapart := split(version, &quot;-&quot;)</span><br><span class="line">	start := split(datapart[0], &quot;.&quot;)</span><br><span class="line">	end := split(datapart[1], &quot;.&quot;)</span><br><span class="line">	test := split(testVersion, &quot;.&quot;)</span><br><span class="line">	for i := 0; i &lt; len(test); i++ &#123;</span><br><span class="line">		startNum, _ := strconv.Atoi(start[i])</span><br><span class="line">		endNum, _ := strconv.Atoi(end[i])</span><br><span class="line">		testNum, _ := strconv.Atoi(test[i])</span><br><span class="line">		if startNum &lt;= testNum &amp;&amp; testNum &lt;= endNum &#123;</span><br><span class="line">			return true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	testStr := []string&#123;</span><br><span class="line">		&quot;CVE-2021-3744#55#4.12.0-5.15.0#4.14.249;5.14.10;5.4.141&quot;,</span><br><span class="line">		&quot;CVE-2022-4382#64#5.3.0-6.2.0#5.10.165;5.4.230;6.1.8&quot;,</span><br><span class="line">		&quot;CVE-2023-0469#56#5.19.0-6.1.5#6.0.11&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	res := solution(testStr, &quot;6.1.4&quot;)</span><br><span class="line">	for _, val := range res &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>相同长度的轨道</title>
    <url>/sameLengthTrack/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>您正在制作两条轨道并希望它们具有最大长度，并且两条轨道的长度必须相等。 现在，您有一堆可以焊接在一起的钢筋，钢筋无法切割，但并非所有钢筋都需要在此过程中耗尽。<br> <br>例如，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起以形成长度为 6 的支撑。（单位为米。）<br> <br>返回轨道的最大可能长度，如果无法创建轨道，则返回 0。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><ul>
<li>输入：[1,2,3,6]</li>
<li>输出：6</li>
<li>解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们的和与 6 相同。</li>
</ul>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><ul>
<li>输入：[1,2,3,4,5,6]</li>
<li>输出：10</li>
<li>解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们的和与 10 相同，并且留下了长度为 1 的条。</li>
</ul>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><ul>
<li><p>输入：[1,2]</p>
</li>
<li><p>输出：0</p>
</li>
<li><p>说明：无法创建轨迹，因此返回0。</p>
<p>但第三天后，仓库 1 和 2 都会再次遇到货物入库，所以不管我们第三天清空哪个仓库，另一个仓库都会发生爆仓。</p>
</li>
</ul>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>0 &lt;&#x3D; 钢筋长度 &lt;&#x3D; 140</li>
<li>1 &lt;&#x3D; 钢筋[i] &lt;&#x3D; 1000</li>
<li>总和(钢筋[i]) &lt;&#x3D; 5000</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>c++版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 1,2,3,6 -&gt; 6</span><br><span class="line">// 1,2,3,4,5,6 -&gt; 10</span><br><span class="line">// 1,2 -&gt; 0</span><br><span class="line">// dp 判断是否能划分成两个相等的子集</span><br><span class="line">bool canPartition(vector&lt;int&gt; nums) &#123;</span><br><span class="line">	// 长度小于2肯定不能划分</span><br><span class="line">	if (nums.size() &lt; 2)</span><br><span class="line">	        return false;</span><br><span class="line">	// 如果和是奇数也不能被划分</span><br><span class="line">	int sum = accumulate(nums.begin(), nums.end(), 0);</span><br><span class="line">	if (sum &amp; 1)</span><br><span class="line">	        return false;</span><br><span class="line">	// 计算最大值，如果最大值大于均值，也不能被划分</span><br><span class="line">	int max = *max_element(nums.begin(), nums.end());</span><br><span class="line">	int target = sum / 2;</span><br><span class="line">	if (max &gt; target)</span><br><span class="line">	        return false;</span><br><span class="line">	// dp[i][j]从0~i里面取若干数的和是否等于j</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt; dp(nums.size(), vector&lt;int&gt;(target + 1, 0));</span><br><span class="line">	for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">		dp[i][0] = true;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[0][nums[0]] = true;</span><br><span class="line">	// for循环i从第一个开始</span><br><span class="line">	for (int i = 1; i &lt; nums.size(); i++) &#123;</span><br><span class="line">		int num = nums[i];</span><br><span class="line">		for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">			if (j &gt;= num) &#123;</span><br><span class="line">				dp[i][j] = dp[i - 1][j - 1] || dp[i - 1][j - num];</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[nums.size() - 1][target];</span><br><span class="line">&#125;</span><br><span class="line">int sameLengthStack(vector&lt;int&gt; nums) &#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	sort(nums.begin(), nums.end());</span><br><span class="line">	for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">		vector&lt;int&gt; newNums;</span><br><span class="line">		// 排序后每次都去掉最小的，看是否能划分成两个相等的子集</span><br><span class="line">		newNums.assign(nums.begin() + i, nums.end());</span><br><span class="line">		bool isCanPartition = canPartition(newNums);</span><br><span class="line">		if (isCanPartition) &#123;</span><br><span class="line">			int sum = accumulate(newNums.begin(), newNums.end(), 0);</span><br><span class="line">			res = sum / 2;</span><br><span class="line">			return res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;int&gt; nums &#123;</span><br><span class="line">		1, 2</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br><span class="line">	int res = sameLengthStack(nums);</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>go版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func IsCanPartition(nums []int) bool &#123;</span><br><span class="line">	if len(nums) &lt; 2 &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	sumNum := CalculateSum(nums)</span><br><span class="line">	if sumNum%2 != 0 &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	maxNum := nums[0]</span><br><span class="line">	for i := 1; i &lt; len(nums); i++ &#123;</span><br><span class="line">		num := nums[i]</span><br><span class="line">		if maxNum &lt; num &#123;</span><br><span class="line">			maxNum = num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if maxNum &gt; sumNum/2 &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	target := sumNum / 2</span><br><span class="line">	//行数</span><br><span class="line">	dp := make([][]bool, len(nums))</span><br><span class="line">	//列数</span><br><span class="line">	for i := range dp &#123;</span><br><span class="line">		dp[i] = make([]bool, target+1)</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; len(nums); i++ &#123;</span><br><span class="line">		dp[i][0] = true</span><br><span class="line">	&#125;</span><br><span class="line">	dp[0][nums[0]] = true</span><br><span class="line">	for i := 1; i &lt; len(nums); i++ &#123;</span><br><span class="line">		num := nums[i]</span><br><span class="line">		for j := 1; j &lt;= target; j++ &#123;</span><br><span class="line">			if j &gt; num &#123;</span><br><span class="line">				dp[i][j] = dp[i-1][j] || dp[i-1][j-num]</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				dp[i][j] = dp[i-1][j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[len(nums)-1][target]</span><br><span class="line">&#125;</span><br><span class="line">func CalculateSum(nums []int) int &#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	for _, num := range nums &#123;</span><br><span class="line">		sum += num</span><br><span class="line">	&#125;</span><br><span class="line">	return sum</span><br><span class="line">&#125;</span><br><span class="line">func SameLengthStack(nums []int) int &#123;</span><br><span class="line">	sort.Slice(nums, func(i, j int) bool &#123;</span><br><span class="line">		return i &lt; j</span><br><span class="line">	&#125;)</span><br><span class="line">	for i := 0; i &lt; len(nums); i++ &#123;</span><br><span class="line">		numsEx := nums[i:]</span><br><span class="line">		if IsCanPartition(numsEx) &#123;</span><br><span class="line">			sum := CalculateSum(numsEx)</span><br><span class="line">			return sum / 2</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1,2,3,6 -&gt; 6</span><br><span class="line">// 1,2,3,4,5,6 -&gt; 10</span><br><span class="line">// 1,2 -&gt; 0</span><br><span class="line">func main() &#123;</span><br><span class="line">	var nums = []int&#123;1, 2&#125;</span><br><span class="line">	res := SameLengthStack(nums)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>backpack</tag>
      </tags>
  </entry>
  <entry>
    <title>防止爆仓</title>
    <url>/preventLiquidation/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>你的工厂有无数个仓库，所有仓库一开始都是空的。如果第 n 个仓库货物入库前是空的，那么它就会装入货物。如果第 n 个仓库货物入库前是 满的 ，这个仓库会爆仓 。你的目标是任意一个仓库都不能爆仓。</p>
<p>给你一个整数数组 repos ，其中：</p>
<ul>
<li>repos[i] &gt; 0 表示第 i 天时，第 repos[i] 个仓库会有货物入库。</li>
<li>repos[i] &#x3D;&#x3D; 0 表示第 i 天没有仓库有货物入库，你可以选择 一个 货运车队清空这个仓库的全部货物。</li>
</ul>
<p>请返回一个数组 ans ，满足：</p>
<p>ans.length &#x3D;&#x3D; repos.length</p>
<ul>
<li><p>如果 repos[i] &gt; 0 ，那么<code>ans[i] == -1</code> 。</p>
</li>
<li><p>如果 repos<code>[i] == 0</code> ，<code>ans[i]</code> 是你第 i 天选择清空的仓库。</p>
<p>如果有多种可行解，请返回它们中的 任意一个<br>如果没办法阻止爆仓，请返回一个 空的数组 。</p>
<p>请注意，如果你选择清空一个装满货物的仓库，它会变成一个空的仓库。但如果你选择清空一个空的仓库，那么将无事发生。</p>
</li>
</ul>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><ul>
<li><p>输入：repos &#x3D; <code>[1,2,3,4]</code></p>
</li>
<li><p>输出：<code>[-1,-1,-1,-1]</code></p>
</li>
<li><p>解释：第一天后，满仓的仓库包括 <code>[1]</code></p>
<p>第二天后，满仓的仓库包括 <code>[1,2]</code></p>
<p>第三天后，满仓的仓库包括 <code>[1,2,3]</code></p>
<p>第四天后，满仓的仓库包括 <code>[1,2,3,4]</code></p>
<p>没有哪一天你可以清空任何仓库，也没有仓库会发生爆仓。</p>
</li>
</ul>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><ul>
<li><p>输入：repos &#x3D; <code>[1,2,0,0,2,1]</code></p>
</li>
<li><p>输出：<code>[-1,-1,2,1,-1,-1]</code></p>
</li>
<li><p>解释：第一天后，满仓的仓库包括 <code>[1]</code></p>
<p>第二天后，满仓的仓库包括 <code>[1,2]</code></p>
<p>第三天后，我们清空仓库 2 。所以剩下满仓的仓库包括<br><code>[1]</code></p>
<p>第四天后，我们清空仓库 1 。所以暂时没有满仓的仓库了。</p>
<p>第五天后，满仓的仓库包括 <code>[2]</code>。</p>
<p>第六天后，满仓的仓库包括 <code>[1,2]</code>。</p>
<p>可以看出，这个方案下不会有爆仓发生。同时，<code>[-1,-1,1,2,-1,-1]</code> 也是另一个可行的没有爆仓的方案。</p>
</li>
</ul>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><ul>
<li><p>输入：repos &#x3D; <code>[1,2,0,1,2]</code></p>
</li>
<li><p>输出：<code>[]</code></p>
</li>
<li><p>解释：第二天后，满仓的仓库包括 <code>[1,2]</code>。我们可以在第三天清空一个仓库。</p>
<p>但第三天后，仓库 1 和 2 都会再次遇到货物入库，所以不管我们第三天清空哪个仓库，另一个仓库都会发生爆仓。</p>
</li>
</ul>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li><code>1 &lt;= repos.length &lt;= 105</code></li>
<li><code>0 &lt;= repos[i] &lt;= 109</code></li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>c++版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// demo</span><br><span class="line">// 1,2,3,4-&gt;[-1,-1,-1,-1]</span><br><span class="line">// 1,2,0,0,2,1-&gt;[-1,-1,2,1,-1,-1]</span><br><span class="line">// 1,2,0,1,2-?&gt;[]</span><br><span class="line">vector&lt;int&gt; preventOverFlow(vector&lt;int&gt; repos) &#123;</span><br><span class="line">	int days = repos.size();</span><br><span class="line">	// 存储仓库内的货物，1：有， 0：无</span><br><span class="line">	unordered_map&lt;int, int&gt; warehouses;</span><br><span class="line">	vector&lt;int&gt; result(days, -1);</span><br><span class="line">	for (int i = 0; i &lt; days; i++) &#123;</span><br><span class="line">		// 当前天需要放货物到仓库，判断仓库是否可放</span><br><span class="line">		if (repos[i] &gt; 0) &#123;</span><br><span class="line">			// 仓库内有货物，不能放，溢出了</span><br><span class="line">			if (warehouses.count(repos[i]) &gt; 0 &amp;&amp; warehouses[repos[i]] &gt; 0) &#123;</span><br><span class="line">				return &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 仓库内无货物，能放，入库</span><br><span class="line">				warehouses[repos[i]]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 当天可以选择一个仓库入库，选择后面需要放东西的仓库, 并且该仓库里有东西</span><br><span class="line">			for (int j = i + 1; j &lt; days; j++) &#123;</span><br><span class="line">				if (repos[j] &gt; 0 &amp;&amp; warehouses.count(repos[j]) &gt; 0 &amp;&amp; warehouses[repos[j]] &gt; 0) &#123;</span><br><span class="line">					result[i] = repos[j];</span><br><span class="line">					warehouses[repos[j]]--;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;int&gt; repos = &#123;</span><br><span class="line">		1, 2, 0, 0, 2, 1</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br><span class="line">	vector&lt;int&gt; result = preventOverFlow(repos);</span><br><span class="line">	if (result.empty()) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;[]&quot; &lt;&lt; endl;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		cout &lt;&lt; &quot;[&quot;;</span><br><span class="line">		for (int i = 0; i &lt; result.size(); i++) &#123;</span><br><span class="line">			cout &lt;&lt; result[i];</span><br><span class="line">			if (i &lt; result.size() - 1) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>go版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// demo</span><br><span class="line">// 1,2,3,4-&gt;[-1,-1,-1,-1]</span><br><span class="line">// 1,2,0,0,2,1-&gt;[-1,-1,2,1,-1,-1]</span><br><span class="line">// 1,2,0,1,2-?&gt;[]</span><br><span class="line">func preventOverflow(repos []int) []int &#123;</span><br><span class="line">	days := len(repos)</span><br><span class="line">	result := make([]int, days)</span><br><span class="line">	for i := range result &#123;</span><br><span class="line">		result[i] = -1</span><br><span class="line">	&#125;</span><br><span class="line">	//存储仓库的货物，1：有， 0：没有</span><br><span class="line">	warehouses := make(map[int]int)</span><br><span class="line">	//遍历每天</span><br><span class="line">	for i := 0; i &lt; days; i++ &#123;</span><br><span class="line">		//需要存货物到仓库</span><br><span class="line">		if repos[i] &gt; 0 &#123;</span><br><span class="line">			//该仓库有货物, 溢出</span><br><span class="line">			if warehouses[repos[i]] &gt; 0 &#123;</span><br><span class="line">				return []int&#123;&#125;</span><br><span class="line">			&#125; else &#123; //没有货物，直接存货物</span><br><span class="line">				warehouses[repos[i]]++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123; //不需要存货物到仓库， 可以出库：找到下一个需要存货物的仓库出库，并且该仓库里有货物</span><br><span class="line">			for j := i + 1; j &lt; days; j++ &#123;</span><br><span class="line">				if repos[j] &gt; 0 &amp;&amp; warehouses[repos[j]] &gt; 0 &#123;</span><br><span class="line">					result[i] = repos[j]</span><br><span class="line">					warehouses[repos[j]]--</span><br><span class="line">					break //找到就不找了</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var repos = []int&#123;1, 2, 0, 0, 2, 1&#125;</span><br><span class="line">	result := preventOverflow(repos)</span><br><span class="line">	fmt.Print(&quot;[&quot;)</span><br><span class="line">	for i := 0; i &lt; len(result); i++ &#123;</span><br><span class="line">		fmt.Print(result[i])</span><br><span class="line">		if i &lt; len(result)-1 &#123;</span><br><span class="line">			fmt.Print(&quot;,&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print(&quot;]&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>程序结构</title>
    <url>/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><p>[toc]</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul>
<li>go语言主要有四种类型的声明语句：<br>  var const type func 分别对应变量 常量 类型 函数的声明</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>var 变量名 类型 &#x3D; 表达式<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;EC&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>省略类型将根据表达式推导变量的类型信息</p>
</li>
<li><p>省略初始化表达式将用零初值初始化该变量</p>
<ol>
<li>数值 0</li>
<li>布尔变量 false</li>
<li>字符串 “”</li>
<li>接口或引用 nil</li>
<li>数组、结构体等 每个字段、元素都是对应类型的零值</li>
</ol>
</li>
<li><p>在包级别声明的变量会在main入口函数执行前完成初始化</p>
</li>
<li><p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f,err = os.Open(filename)</span><br></pre></td></tr></table></figure></li>
<li><p>函数内部可以通过 <code>变量名 := 表达式</code> 声明变量 - 简短变量声明</p>
<ol>
<li><p>变量类型根据表达式自动推导</p>
</li>
<li><p>通过 <code>:=</code> 的方式声明多个变量，已经声明过的变量将只有赋值行为</p>
</li>
</ol>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line">out, err := os.Create(outfile) <span class="comment">// error -&gt; 重新赋值</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>至少要有一个声明的新变量，否则编译不通过</li>
</ol>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><u>简短变量</u>声明被广泛用于大部分的<strong>局部变量</strong>的声明和初始化; <u>var形式</u>的声明语句往往是用于需要<strong>显式指定变量类型的地方</strong>，或者因为变量<strong>稍后会被重新赋值</strong>而初始值无关紧要的地方</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>“var x int”声明语句声明一个x变量，&amp;x将产生一个指向该整数变量的指针，指针对应的数据类型为<code>*int</code>，<code>*p</code>表达式读取指针指向的变量的值</li>
<li>指针的零值为nil</li>
<li>在Go语言中，返回函数中局部变量的地址也是安全的，因为指针依然引用这个变量</li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="new()"></a>new()</h3><ul>
<li>new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code></li>
<li>new只是一个预定义的函数，它并不是一个关键字</li>
<li>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这个选择并不是由用var还是new声明变量的方式决定的</li>
<li>局部变量从函数f中逃逸，该局部变量会被分配到堆上</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>一个类型声明语句创建了一个新的类型名称</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure>

<ul>
<li>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</li>
<li>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型，只有当两个类型的底层基础类型相同时，才允许这种转型操作</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul>
<li><p>一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中</p>
</li>
<li><p>每个包都对应一个独立的名字空间</p>
</li>
<li><p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息，在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的</p>
</li>
<li><p>初始化函数</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个文件都可以包含多个init初始化函数，这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似，在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数声明包括函数名，形参列表，返回值列表(可省)，函数体</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span></span> (result-list) &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的</li>
<li>函数可以返回多返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(rect image.Rectangle)</span></span> (width, height <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><ul>
<li><p>对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息，如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok；导致失败的原因不止一种，需要了解更多的错误信息，额外的返回值不再是简单的布尔类型，而是error类型</p>
</li>
<li><p>可以通过调用error的Error函数或者输出函数获得字符串类型的错误信</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br></pre></td></tr></table></figure>

<ul>
<li>EOF</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read failed:%v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...use r…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><ul>
<li>函数像其他值一样，可以被赋值给其他变量，函数类型的零值是nil，调用函数值为nil的函数会引起panic错误</li>
<li>函数值可以与nil比较，函数值之间不可比较，不能用函数值作为map的key</li>
<li>匿名函数：func后没有函数名</li>
<li>函数做参数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foreach</span><span class="params">(l []<span class="type">int</span>, f <span class="keyword">func</span>(n <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> l &#123;</span><br><span class="line">		f(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">foreach(l, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span>&#123; fmt.Println(n) &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>需要在参数列表的最后一个参数类型之前加上”…”</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>)</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// vals被看作类型为[]int的切片</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原始参数已经是切片类型，只需要在最后一个参数上加”…”</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum()</span><br></pre></td></tr></table></figure>

<h3 id="deffer函数"><a href="#deffer函数" class="headerlink" title="deffer函数"></a>deffer函数</h3><ul>
<li><p>直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行</p>
</li>
<li><p>可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反</p>
</li>
<li><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁</p>
</li>
<li><p>采用defer机制，可以使其观察函数的返回值</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;double(%d) = %d\n&quot;</span>, x,result) &#125;()</span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ = double(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h3><ul>
<li><p>有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起panic异常</p>
</li>
<li><p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息</p>
</li>
<li><p>直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数</p>
</li>
</ul>
<h3 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h3><ul>
<li><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value</p>
</li>
<li><p>在未发生panic时调用recover，recover会返回nil</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>在声明函数时，在函数名前附加一个参数，即为这种类型定义方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">p.Distance(q)  <span class="comment">// &quot;5&quot;, method call</span></span><br></pre></td></tr></table></figure>

<ul>
<li>附加的参数p叫做方法的接收器</li>
<li>Go不回像其他语言那样用this或self作为接收器，可以任意选择接受器的名字，建议使用第一个字母</li>
<li>我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型<strong>不是指针或者interface</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span></span> Distance() <span class="type">float64</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125; <span class="comment">// 为slice类型定义方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，可以用到指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> MoveTo(position Point) &#123;</span><br><span class="line">    p.X *= position.X</span><br><span class="line">    p.Y *= position.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := &amp;Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">p.MoveTo(Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">q := Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">q.MoveTo(Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器会隐式地帮我们用&amp;p去调用MoveTo这个方法。这种简写方法只适用于“变量”</li>
<li>nil也是一个合法的接收器类型</li>
<li>内嵌结构体来扩展类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutex被匿名内嵌到cache中，cache也可以调用Lock与Unlock方法</span></span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例</li>
<li>io包中定义了很多有用的接口类型，Writter提供了所有类型的写入bytes的抽象，Reader可以代表任意可以读取bytes的类型，Closer可以是任意可以关闭的值</li>
<li>可以通过组合已有接口定义新的接口类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表达一个类型属于某个接口只要这个类型实现这个接口</li>
<li>interface{} 表示空接口类型</li>
<li>一个接口的值由两部分组成，一个具体的类型和那个类型的值，空指针不等于空接口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> emptyI <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;a == nil&quot;</span>, a == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;emptyI == nil&quot;</span>, emptyI == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;a == emptyI&quot;</span>, a == emptyI) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Goroutines-amp-Channels"><a href="#Goroutines-amp-Channels" class="headerlink" title="Goroutines &amp; Channels"></a>Goroutines &amp; Channels</h2><ul>
<li>Go语言中，每个并发的执行单元叫作一个goroutine</li>
<li>程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine</li>
<li>新的goroutine会用go语句来创建，go语句会使其语句中的函数在一个新创建的goroutine中运行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> f()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息</p>
</li>
<li><p>创建channels</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>channel是引用类型，当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用</li>
<li>两个channel可以用&#x3D;&#x3D;比较，当两个channel引用的是相同的对象，为true</li>
<li>channel有发送和接受两个主要操作，一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine，发送和接收都使用<code>&lt;-</code>运算符</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x   <span class="comment">// send statement</span></span><br><span class="line">x = &lt;-ch  <span class="comment">// receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch 			<span class="comment">// receive statement;result is discarded</span></span><br></pre></td></tr></table></figure>

<ul>
<li>内置的close函数可以关闭一个channel，关闭的channel随后基于channel的任何发送操作都将导致panic异常，对于一个已经被close过的channel进行接收操作依然可以接收之前已经发送成功的数据</li>
<li>如果channel中已经没有数据将产生一个零值数据</li>
<li><code>make(chan int)</code>创建的是一个无缓存的channel，也可以指定第二个整型参数，对应channel的容量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// bufferd channel with capacity 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个基于无缓存channel的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的channel上执行接收操作；反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同channel上执行发送操作</li>
<li>基于无缓存channel的发送和接收操作将导致两个goroutine做一次同步操作，无缓存channel也被称为同步channel</li>
<li>当一个无缓存channel发送数据时，接收者先收到数据，然后发送者goroutine被再次唤醒</li>
<li>当仅仅是用作同步两个goroutine，可以用<code>struct&#123;&#125;</code>空结构体作为channel元素的类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;-done</span><br></pre></td></tr></table></figure>

<ul>
<li>channel可以用于将多个goroutine连接在一起，一个channel的输出作为下一个channel的输入，这种串联的channel就是管道(pipeline)</li>
<li>range循环可以直接在channel上面迭代，当channel被关闭且没有值可以接收时跳出循环</li>
<li>类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收</li>
<li>类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送</li>
<li>对只接收channel调用close时编译错误</li>
<li>任何双向channel向单向channel的变量赋值操作都将导致隐式转换，不能将一个单向channel转换为双向channel</li>
<li>带缓存的channel内部持有一个元素队列，向channel发送操作是向队列尾部插入元素，接收操作则是从头部删除元素</li>
<li>如果带缓存channel缓存队列是满的，发送操作将阻塞直到另一个goroutine执行接收操作释放了新的队列空间，相反如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素</li>
<li>内置的cap函数可以获取channel内部的缓存容量</li>
<li>goroutine因为没有人接收而被永远阻塞，成为goroutine泄漏，要确保每个不再需要的goroutine能正常退出</li>
<li>select语句会等待case中有能够执行的case时去执行，当条件满足才会去通信并执行case之后的语句，这时候其他通信不会执行。每个case代表一个通信操作（在channel上进行发送或接收）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果多个case同时就绪，select会随机选择一个执行，select的default来设置当其他的操作都不能够马上被处理时程序需要执行哪些逻辑，所以用来避免因为发送或接收导致的阻塞</li>
<li>用select实现非阻塞的接收操作，反复这样的操作叫做loop channel</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> x</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> x &lt;-ch:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;select default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go basic</tag>
      </tags>
  </entry>
  <entry>
    <title>goinactionChapter5-9</title>
    <url>/goinactionChapter5-9/</url>
    <content><![CDATA[<h1 id="Go语言的类型系统"><a href="#Go语言的类型系统" class="headerlink" title="Go语言的类型系统"></a>Go语言的类型系统</h1><h2 id="用户定义的类型"><a href="#用户定义的类型" class="headerlink" title="用户定义的类型"></a>用户定义的类型</h2><h3 id="struct创建结构类型"><a href="#struct创建结构类型" class="headerlink" title="struct创建结构类型"></a>struct创建结构类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name       <span class="type">string</span></span><br><span class="line">    email      <span class="type">string</span></span><br><span class="line">    ext        <span class="type">int</span></span><br><span class="line">    privileged <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）使用<br>var bill user -&gt;  声明时总是会被初始化，结构里的每个字段都会用零值初始化（数值类型零值:0, 字符串零值：空字符串，布尔类型：false)<br>（2）note<br>var和 :&#x3D; 的区别<br>var是创建一个变量并初始化为其零值<br>:&#x3D; 结合字面量 可以将变量初始化为某个非零值(根据右侧的类型信息作为声明变量的类型）<br>eg: lisa :&#x3D; user{<br>name:”lisa”,<br>email:”<a href="mailto:&#108;&#x69;&#115;&#97;&#x40;&#101;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#108;&#x69;&#115;&#97;&#x40;&#101;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a>“,<br>ext:123,<br>privileged:true,<br>} -&gt; 初始化结构类型 使用 结构字面量, 对字段声明顺序没有要求<br>lisa :&#x3D; user{“lisa”, “<a href="mailto:&#108;&#105;&#x73;&#97;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;">&#108;&#105;&#x73;&#97;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;</a>“, 123, true} -&gt; 只有值，没有字段名，结尾不需要逗号，值得顺序要和结构类型一致<br>（3）使用用户自定义结构类型声明字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    person user</span><br><span class="line">    level  <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fred := admin&#123;</span><br><span class="line">        person: user&#123;</span><br><span class="line">            name:       <span class="string">&quot;fred&quot;</span>,</span><br><span class="line">            email:      <span class="string">&quot;fred@email.com&quot;</span>,</span><br><span class="line">            ext:        <span class="number">456</span>,</span><br><span class="line">            privileged: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        level: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>初始化person字段是使用结构字面量创建了user类型的值</p>
<h3 id="基于已有的类型，作为新类型的类型说明"><a href="#基于已有的类型，作为新类型的类型说明" class="headerlink" title="基于已有的类型，作为新类型的类型说明"></a>基于已有的类型，作为新类型的类型说明</h3><p>Duration in time package<br><img src="/images/goinaction10.png" alt="image.png"><br>int64是Duration的基础类型，但是go不认为int64和Duration是同一类型。Duration是一个独立的类型，编译器不会做隐式转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duration <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dur Duration</span><br><span class="line">    dur = <span class="type">int64</span>(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错：<br>cannot use int64(1000) (constant 1000 of type int64) as Duration value in assignment</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是给用户定义的类型添加新的行为，在关键字func和方法名之间增加了一个参数<br>函数有接收者，就被称为方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show how to declare methods and how the Go</span></span><br><span class="line"><span class="comment">// compiler supports them.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user defines a user in the program.</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="type">string</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify implements a method with a value receiver.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending User Email To %s&lt;%s&gt;\n&quot;</span>,</span><br><span class="line">        u.name,</span><br><span class="line">        u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// changeEmail implements a method with a pointer receiver.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> changeEmail(email <span class="type">string</span>) &#123;</span><br><span class="line">    u.email = email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Values of type user can be used to call methods</span></span><br><span class="line">    <span class="comment">// declared with a value receiver.</span></span><br><span class="line">    bill := user&#123;<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;bill@email.com&quot;</span>&#125;</span><br><span class="line">    bill.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointers of type user can also be used to call methods</span></span><br><span class="line">    <span class="comment">// declared with a value receiver.</span></span><br><span class="line">    lisa := &amp;user&#123;<span class="string">&quot;Lisa&quot;</span>, <span class="string">&quot;lisa@email.com&quot;</span>&#125;</span><br><span class="line">    lisa.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values of type user can be used to call methods</span></span><br><span class="line">    <span class="comment">// declared with a pointer receiver.</span></span><br><span class="line">    bill.changeEmail(<span class="string">&quot;bill@newdomain.com&quot;</span>)</span><br><span class="line">    bill.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointers of type user can be used to call methods</span></span><br><span class="line">    <span class="comment">// declared with a pointer receiver.</span></span><br><span class="line">    lisa.changeEmail(<span class="string">&quot;lisa@newdomain.com&quot;</span>)</span><br><span class="line">    lisa.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序声明了user结构类型</p>
<ul>
<li>使用值接收者实现方法: func (u user) notify()</li>
</ul>
<p>(1)user类型的值来调用方法<br>bill :&#x3D; user{“Bill”, “<a href="mailto:&#98;&#105;&#x6c;&#x6c;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;">&#98;&#105;&#x6c;&#x6c;&#64;&#x65;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;</a>“}<br>bill.notify()<br>(2)user类型的指针调用方法<br>lisa :&#x3D; &amp;user{“Lisa”, “<a href="mailto:&#x6c;&#105;&#115;&#97;&#x40;&#x65;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#105;&#115;&#97;&#x40;&#x65;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a>“}<br>lisa.notify()<br>go语言调整指针的值来符合方法的定义-&gt; (*lisa).notify()</p>
<ul>
<li>使用指针接收者实现方法: func (u *user) changeEmail(email string)</li>
</ul>
<p>(1)user类型的指针调用方法<br>lisa :&#x3D; &amp;user{“Lisa”, “<a href="mailto:&#108;&#x69;&#x73;&#97;&#x40;&#x65;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;">&#108;&#x69;&#x73;&#97;&#x40;&#x65;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a>“}<br>lisa.changeEmail(“<a href="mailto:&#108;&#x69;&#x73;&#x61;&#64;&#x6e;&#x65;&#x77;&#x64;&#x6f;&#109;&#x61;&#105;&#110;&#x2e;&#x63;&#x6f;&#109;">&#108;&#x69;&#x73;&#x61;&#64;&#x6e;&#x65;&#x77;&#x64;&#x6f;&#109;&#x61;&#105;&#110;&#x2e;&#x63;&#x6f;&#109;</a>“)<br>(2)user类型的值来调用方法<br>bill :&#x3D; user{“Bill”, “<a href="mailto:&#98;&#x69;&#108;&#108;&#x40;&#101;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;">&#98;&#x69;&#108;&#108;&#x40;&#101;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a>“}<br>bill.changeEmail(“<a href="mailto:&#x62;&#105;&#x6c;&#108;&#x40;&#110;&#x65;&#119;&#x64;&#111;&#109;&#97;&#105;&#x6e;&#x2e;&#x63;&#x6f;&#109;">&#x62;&#105;&#x6c;&#108;&#x40;&#110;&#x65;&#119;&#x64;&#111;&#109;&#97;&#105;&#x6e;&#x2e;&#x63;&#x6f;&#109;</a>“)<br>go语言调整值来符合方法的定义-&gt; （&amp;bill).changeEmail(“<a href="mailto:&#98;&#105;&#x6c;&#x6c;&#64;&#x6e;&#x65;&#119;&#x64;&#x6f;&#109;&#x61;&#105;&#x6e;&#x2e;&#99;&#x6f;&#109;">&#98;&#105;&#x6c;&#x6c;&#64;&#x6e;&#x65;&#119;&#x64;&#x6f;&#109;&#x61;&#105;&#x6e;&#x2e;&#99;&#x6f;&#109;</a>“)</p>
<ul>
<li>go语言的两种类型的接收者:</li>
</ul>
<p>(1)值接收者：调用时使用值得副本来执行<br>适用于创建新的值<br>(2）指针接收者：调用时使用实际值来执行<br>适用于修改当前值</p>
<h2 id="类型的本质"><a href="#类型的本质" class="headerlink" title="类型的本质"></a>类型的本质</h2><p>关注值的本质</p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>数值类型，字符串类型，布尔类型<br>把这些类型的值传递给方法或者函数时，传递的是对应值的副本</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>切片，映射，通道，接口，函数类型(type MyFunc func(int, int) int<br>)<br>引用类型都包含一组独特的字段，用于管理底层数据结构。因此通过复制来传递一个引用类型的副本，本质是共享底层数据结构</p>
<ul>
<li>编译器只允许为命名的用户定义的类型声明方法：</li>
</ul>
<p>(1)因为未命名类型没有独立的命名空间，无法与其他代码分开管理。<br>(2)应该使用具名类型来管理代码并添加方法。当我们声明一个结构体或接口时，我们可以向其中添加方法，以便更好地管理该类型的行为。这些方法只能在类型所属的包中使用，并且必须通过该类型来调用</p>
<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>结构类型用来描述一组数据值，这组值得本质可以是原始的，也可以是非原始的</p>
<h4 id="原始的类型的结构类型"><a href="#原始的类型的结构类型" class="headerlink" title="原始的类型的结构类型"></a>原始的类型的结构类型</h4><p>time package里的Time类型是原始的<br><img src="/images/goinaction11.png" alt="image.png"><br><img src="/images/goinaction12.png" alt="image.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add returns the time t+d.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time &#123;</span><br><span class="line">    dsec := <span class="type">int64</span>(d / <span class="number">1e9</span>)</span><br><span class="line">    nsec := t.nsec() + <span class="type">int32</span>(d%<span class="number">1e9</span>)</span><br><span class="line">    <span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">        dsec++</span><br><span class="line">        nsec -= <span class="number">1e9</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</span><br><span class="line">        dsec--</span><br><span class="line">        nsec += <span class="number">1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.wall = t.wall&amp;^nsecMask | <span class="type">uint64</span>(nsec) <span class="comment">// update nsec</span></span><br><span class="line">    t.addSec(dsec)</span><br><span class="line">    <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">        te := t.ext + <span class="type">int64</span>(d)</span><br><span class="line">        <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; te &gt; t.ext || d &gt; <span class="number">0</span> &amp;&amp; te &lt; t.ext &#123;</span><br><span class="line">            <span class="comment">// Monotonic clock reading now out of range; degrade to wall-only.</span></span><br><span class="line">            t.stripMono()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t.ext = te</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time类型的方法，使用值接收者，传入Time值得副本，返回了方法内得Time值得副本</p>
<h4 id="非原始的类型的结构类型"><a href="#非原始的类型的结构类型" class="headerlink" title="非原始的类型的结构类型"></a>非原始的类型的结构类型</h4><p>os package里的File类型是非原始的<br><img src="/images/goinaction13.png" alt="image.png"><br><img src="/images/goinaction14.png" alt="image.png"><br>File类型使用了嵌入的指针，指向未公开的类型，这层额外的内嵌类型组织了复制<br>在对File类型进行复制时，只会复制<em>file指针本身，而不会复制指向的file类型数据。这意味着，复制后的File类型和原始的File类型将共享同一个</em>file指针，并且对其中一个的修改也会影响到另一个<br>函数：<br>调用者得到指向File类型值得指针-&gt; 说明被返回得值是非原始得<br><img src="/images/goinaction15.png" alt="image.png"></p>
<p>方法：<br>没有修改接收者得值，但是使用指针接收者来声明<br><img src="/images/goinaction16.png" alt="image.png"></p>
<p>总结：<br>（1）即使函数或者方法没有直接改变非原始得值得状态，依旧应该使用共享得方式传递，因为对应类型得数据是非原始得，应该总是被共享，而不是复制</p>
<p>（2）使用值接收者还是指针接收者，不应该由方法是否修改了接收到得值来决定，应该基于类型的本质（除了让类型值符合接口的时候）</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>多态： 代码可以更具类型的具体实现采取不同行为的能力<br>如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值<br>eg：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show how to write a simple version of curl using</span></span><br><span class="line"><span class="comment">// the io.Reader and io.Writer interface support.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// init is called before main.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Usage: ./example2 &lt;url&gt;&quot;</span>)</span><br><span class="line">        os.Exit(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Get a response from the web server.</span></span><br><span class="line">    r, err := http.Get(os.Args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copies from the Body to Stdout.</span></span><br><span class="line">    io.Copy(os.Stdout, r.Body)</span><br><span class="line">    <span class="keyword">if</span> err := r.Body.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy 函数接收io.Reader接口类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>r.Body 是 io.ReadCloser接口类型的值，实现了Reader接口，因此可以传入io.Copy方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）接口是用来定义行为的类型，这些被定义的行为不由接口直接实现，而是通过<strong>方法</strong>由<strong>用户定义的类型</strong>实现<br>（2）用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值<br>（3）对接口值方法的调用会执行接口值里存储的用户定义的类型的值的对应的方法 -&gt; 任何用户定义的类型都可以实现任何接口 -&gt; 对接口值方法的调用就是一种多态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// notifier 是一个接口类型，表示可以向外部发送通知</span></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 是一个结构体类型，表示用户</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 notifier 接口的 notify 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending notification to user %s\n&quot;</span>, u.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个 notifier 类型变量 n，赋值为一个 user 类型变量</span></span><br><span class="line">    <span class="keyword">var</span> n notifier</span><br><span class="line">    n = user&#123;<span class="string">&quot;Bill&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 notifier 接口中定义的 notify 方法，输出 &quot;Sending notification to user Bill&quot;</span></span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将实体值赋值给接口"><a href="#将实体值赋值给接口" class="headerlink" title="将实体值赋值给接口"></a>将实体值赋值给接口</h4><p>var n notifier<br>n &#x3D; user{“Bill”}<br>user类型值赋值后接口变量的值的内部布局：<br>notifier是一个两个字长度的数据结构<br>第一个是指向内部表（iTable）的指针 ： 包含<strong>已存储的值的类型的信息</strong>和与这个值关联的一组方法<br>第二个是一个指向所存储值的指针<br><img src="/images/goinaction17.png" alt="image.png"></p>
<h4 id="将实体指针赋值给接口"><a href="#将实体指针赋值给接口" class="headerlink" title="将实体指针赋值给接口"></a>将实体指针赋值给接口</h4><p>var n notifier<br>n &#x3D; &amp;user{“Bill”}<br>第一个是指向内部表（iTable）的指针 ：<strong>存储一个指向保存的类型的指针</strong>和与这个值关联的一组方法<br>第二个是一个指向所存储值的指针<br><img src="/images/goinaction18.png" alt="image.png"></p>
<h4 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h4><p>方法集定义了接口的接受规则，定义了一组关联到给定类型的值或者指针的方法<br><img src="/images/goinaction19.png" alt="image.png"><br>（1）如果使用指针接收者来实现一个接口，那么只有指向该类型的指针才能实现对应的接口<br>（2）如果使用值接收者来实现一个接口，那么该类型的值和指针都能实现对应的接口</p>
<p>第一条限制存在的原因:<br>编译器不能总是自动获取一个值的地址？？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show how you can&#x27;t always get the</span></span><br><span class="line"><span class="comment">// address of a value.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// duration is a type with a base type of int.</span></span><br><span class="line"><span class="keyword">type</span> duration <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// format pretty-prints the duration value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *duration)</span></span> pretty() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Duration: %d&quot;</span>, *d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    duration(<span class="number">42</span>).pretty()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ./listing46.go:17: cannot call pointer method on duration(42)</span></span><br><span class="line">    <span class="comment">// ./listing46.go:17: cannot take the address of duration(42)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/goinaction20.png" alt="image.png"><br>duration(42).pretty()<br>改成这样就可以<br>var dur &#x3D; duration(42)<br>dur.pretty()</p>
<p>原因：值类型不能被寻址<br>duration(42)返回的值是右值，当调用指针接收者的方法时，编译器试图给其插入取地址符，未果，就只能报错了。<br>左值和右值：最重要区别就是是否可以被寻址<br>可以被寻址的是左值，既可以出现在赋值号左边也可以出现在右边；<br>不可以被寻址的即为右值，比如函数返回值、字面值、常量值等等，只能出现在赋值号右边。</p>
<h3 id="嵌入类型"><a href="#嵌入类型" class="headerlink" title="嵌入类型"></a>嵌入类型</h3><p>(1)允许用户扩展或修改已有类型的行为，将已有的类型直接声明在新的结构类型里<br>(2)被嵌入的类型被称为新的外部类型的内部类型<br>(3)通过嵌入类型，与外部类型相关的标识符会提升到外部类型上</p>
<ul>
<li>外部类型就<strong>组合</strong>了<strong>内部类型</strong>包含的所有<strong>属性</strong>，并可以<strong>添加</strong>新的字段和方法</li>
<li>外部类型也可以通过声明与内部标识符<strong>同名</strong>的标识符来<strong>覆盖内部标识符</strong>的字段或方法</li>
</ul>
<p>嵌入一个类型，只需要声明这个类型的名字即可：不指定内部类型对应的字段名，也可以使用内部类型的类型名，来访问到内部类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show how to embed a type into another type and</span></span><br><span class="line"><span class="comment">// the relationship between the inner and outer type.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user defines a user in the program.</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="type">string</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify implements a method that can be called via</span></span><br><span class="line"><span class="comment">// a value of type user.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending user email to %s&lt;%s&gt;\n&quot;</span>,</span><br><span class="line">        u.name,</span><br><span class="line">        u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// admin represents an admin user with privileges.</span></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user  <span class="comment">// Embedded Type</span></span><br><span class="line">    level <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create an admin user.</span></span><br><span class="line">    ad := admin&#123;</span><br><span class="line">        user: user&#123;</span><br><span class="line">            name:  <span class="string">&quot;john smith&quot;</span>,</span><br><span class="line">            email: <span class="string">&quot;john@yahoo.com&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        level: <span class="string">&quot;super&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can access the inner type&#x27;s method directly.</span></span><br><span class="line">    ad.user.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The inner type&#x27;s method is promoted.</span></span><br><span class="line">    ad.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用是通过直接访问内部类型user -&gt; 内部类型存在于外部类型内，总是可访问的<br>ad.user.notify()<br>内部类型的方法提升到外部类型，直接调用<br>ad.notify()</p>
<p>外部类型不需要使用内部类型的实现，想使用自己的一套实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show what happens when the outer and inner</span></span><br><span class="line"><span class="comment">// type implement the same interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// notifier is an interface that defined notification</span></span><br><span class="line"><span class="comment">// type behavior.</span></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user defines a user in the program.</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="type">string</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify implements a method that can be called via</span></span><br><span class="line"><span class="comment">// a value of type user.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending user email to %s&lt;%s&gt;\n&quot;</span>,</span><br><span class="line">        u.name,</span><br><span class="line">        u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// admin represents an admin user with privileges.</span></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user</span><br><span class="line">    level <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify implements a method that can be called via</span></span><br><span class="line"><span class="comment">// a value of type Admin.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span></span> notify() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending admin email to %s&lt;%s&gt;\n&quot;</span>,</span><br><span class="line">        a.name,</span><br><span class="line">        a.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create an admin user.</span></span><br><span class="line">    ad := admin&#123;</span><br><span class="line">        user: user&#123;</span><br><span class="line">            name:  <span class="string">&quot;john smith&quot;</span>,</span><br><span class="line">            email: <span class="string">&quot;john@yahoo.com&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        level: <span class="string">&quot;super&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the admin user a notification.</span></span><br><span class="line">    <span class="comment">// The embedded inner type&#x27;s implementation of the</span></span><br><span class="line">    <span class="comment">// interface is NOT &quot;promoted&quot; to the outer type.</span></span><br><span class="line">    sendNotification(&amp;ad)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can access the inner type&#x27;s method directly.</span></span><br><span class="line">    ad.user.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The inner type&#x27;s method is NOT promoted.</span></span><br><span class="line">    ad.notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendNotification accepts values that implement the notifier</span></span><br><span class="line"><span class="comment">// interface and sends notifications.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>admin类型增加了对notifier接口的实现 -&gt; 接口嵌入的内部类型实现没有提升到外部类型<br>ad.user.notify() -&gt; 调用内部类型user的方法<br>ad.notify() -&gt; 调用外部类型admin的方法</p>
<p>总结：<br>（1）外部类型实现了和内部类型同名的方法，则内部类型的实现就不会被提升<br>（2）但是内部类型的值一直在，可以直接访问内部类型的值，来访问没有被提升的内部类型实现的方法</p>
<h3 id="公开或未公开的标识符"><a href="#公开或未公开的标识符" class="headerlink" title="公开或未公开的标识符"></a>公开或未公开的标识符</h3><p>go语言支持从包里公开或者隐藏标识符<br>标识符名字以<strong>小写</strong>字母开头：标识符未公开，包外的代码<strong>不可见</strong><br>标识符名字以<strong>大写</strong>字母开头：标识符公开，包外的代码<strong>可见</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> counters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// alertCounter is an unexported type that</span></span><br><span class="line"><span class="comment">// contains an integer counter for alerts.</span></span><br><span class="line"><span class="keyword">type</span> alertCounter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates and returns values of the unexported</span></span><br><span class="line"><span class="comment">// type alertCounter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(value <span class="type">int</span>)</span></span> alertCounter &#123;</span><br><span class="line">    <span class="keyword">return</span> alertCounter(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/goinaction/code/chapter5/listing68/counters&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a variable of the unexported type using the exported</span></span><br><span class="line">    <span class="comment">// New function from the package counters.</span></span><br><span class="line">    counter := counters.New(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Counter: %d\n&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type alertCounter int -&gt; 小写的标识符未公开<br>New 工厂函数创建了未公开类型的值，将这个值返回给调用者（？）<br>原因: alertCounter类型的值是一个具体的值，而不是一个类型。因此，虽然alertCounter类型本身是未公开的，但是它的值并没有被限制在包内部<br>书上：</p>
<ul>
<li>公开或者未公开的标识符，不是一个值</li>
<li>短变量声明操作符，有能力捕获引用的类型</li>
</ul>
<p>嵌入类型+未公开标识符的使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package entities contains support for types of</span></span><br><span class="line"><span class="comment">// people in the system.</span></span><br><span class="line"><span class="keyword">package</span> entities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user defines a user in the program.</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Admin defines an admin in the program.</span></span><br><span class="line"><span class="keyword">type</span> Admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user   <span class="comment">// The embedded type is unexported.</span></span><br><span class="line">    Rights <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show how unexported fields from an exported</span></span><br><span class="line"><span class="comment">// struct type can&#x27;t be accessed directly.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/goinaction/code/chapter5/listing74/entities&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a value of type Admin from the entities package.</span></span><br><span class="line">    a := entities.Admin&#123;</span><br><span class="line">        Rights: <span class="number">10</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the exported fields from the unexported</span></span><br><span class="line">    <span class="comment">// inner type.</span></span><br><span class="line">    a.Name = <span class="string">&quot;Bill&quot;</span></span><br><span class="line">    a.Email = <span class="string">&quot;bill@email.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;User: %v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Admin类型的内部类型user是未公开的，无法直接通过结构字面量初始化改内部类型</li>
<li>虽然内部类型是未公开的，但是内部类型里声明的字段是公开的</li>
<li>内部类型的标识符提升到外部类型，这些公开的字段可以通过外部类型访问到</li>
</ul>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>go语言里的并发是指能让某个函数独立于其他函数运行的能力。<br>当一个函数创建为goroutine时，Go会将其视为一个独立的工作单元。</p>
<p><img src="/images/goinaction21-0.png" alt="image.png"><img src="/images/goinaction21-1.png" alt="image.png"></p>
<ul>
<li>创建一个goroutine就会被放到调度器的全局运行队列中</li>
<li>调度器就将这些队列中的goroutine分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中</li>
<li>本地运行队列中的goroutine一直等待直到自己被分配的逻辑处理器执行</li>
</ul>
<p>goroutine执行阻塞的系统调用：打开文件<br>分离-&gt; 线程阻塞 -&gt; 等待系统调用的返回</p>
<p>并发：让不同的代码片段同时在不同的物理处理器上执行，同时管理很多事情<br>并行：同时做很多事情<br>goroutine并行，需要多于一个逻辑处理器，可以在不同的线程上运行<br>一个逻辑处理器和两个逻辑处理器的区别：<br><img src="/images/goinaction22-0.png" alt="image.png"><img src="/images/goinaction22-1.png" alt="image.png"></p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h3 id="goroutine并发"><a href="#goroutine并发" class="headerlink" title="goroutine并发"></a>goroutine并发</h3><h4 id="一个逻辑处理器并发运行多个goroutine"><a href="#一个逻辑处理器并发运行多个goroutine" class="headerlink" title="一个逻辑处理器并发运行多个goroutine"></a>一个逻辑处理器并发运行多个goroutine</h4><ul>
<li>runtime.GOMAXPROCS(1) 设置逻辑处理器数量是1</li>
<li>WaitGroup是一个计数信号量，用来记录并维护运行的goroutine</li>
<li>如果WaitGroup的值大于0，Wait方法就会阻塞</li>
<li>当代码中函数通过goroutine执行，main代码会继续运行，这样main函数会在goroutine完成工作前返回，程序就有可能在goroutine运行前种植，因此main函数需要通过WaitGroup来等待goroutine完成工作</li>
<li>当goroutine占用时间过长时，调度器会停止当前正运行的goroutine，并给其他可运行的goroutine运行的机会</li>
</ul>
<p><img src="/images/goinaction23.png" alt="image.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how the goroutine scheduler</span></span><br><span class="line"><span class="comment">// will time slice goroutines on a single thread.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Allocate 1 logical processors for the scheduler to use.</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a count of two, one for each goroutine.</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two goroutines.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Create Goroutines&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> printPrime(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> printPrime(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the goroutines to finish.</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Waiting To Finish&quot;</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Terminating Program&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// printPrime displays prime numbers for the first 5000 numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPrime</span><span class="params">(prefix <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Schedule the call to Done to tell main we are done.</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    <span class="keyword">for</span> outer := <span class="number">2</span>; outer &lt; <span class="number">5000</span>; outer++ &#123;</span><br><span class="line">        <span class="keyword">for</span> inner := <span class="number">2</span>; inner &lt; outer; inner++ &#123;</span><br><span class="line">            <span class="keyword">if</span> outer%inner == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s:%d\n&quot;</span>, prefix, outer)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Completed&quot;</span>, prefix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/goinaction24.png" alt="image.png"><br>调度器切换两个goroutine</p>
<h3 id="goroutine并行"><a href="#goroutine并行" class="headerlink" title="goroutine并行"></a>goroutine并行</h3><p>import runtime<br>runtime.GOMAXPROCS(runtime.NumCPU())</p>
<ul>
<li>runtime包修改Go语言运行时配置参数的能力</li>
<li>修改调度器使用的逻辑处理器的数量 -&gt; 为每个可用的物理处理器创建一个逻辑处理器</li>
<li>有多个逻辑处理器 且 可以同时让每个逻辑处理器运行在一个可用的物理处理器上， goroutine才会并行运行</li>
</ul>
<h3 id="竞争状态"><a href="#竞争状态" class="headerlink" title="竞争状态"></a>竞争状态</h3><p>两个goroutine没有互相同步（互斥锁，通道，条件锁）下，访问某个共享的资源，并试图读写这个资源，就会处于互相竞争的状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to create race</span></span><br><span class="line"><span class="comment">// conditions in our programs. We don&#x27;t want to do this.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// counter is a variable incremented by all goroutines.</span></span><br><span class="line">    counter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Add a count of two, one for each goroutine.</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two goroutines.</span></span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the goroutines to finish.</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Final Counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// incCounter increments the package level counter variable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Schedule the call to Done to tell main we are done.</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">        <span class="comment">// Capture the value of Counter.</span></span><br><span class="line">        value := counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Yield the thread and be placed back in queue.</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increment our local value of Counter.</span></span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store the value back into Counter.</span></span><br><span class="line">        counter = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/goinaction25.png" alt="image.png"></p>
<ul>
<li>counter是进行四次读写操作，每个goroutine执行两次</li>
<li>runtime.Gosched()将goroutine从当前线程退出，给其他goroutine运行</li>
<li>用竞争检测器标志来编译程序</li>
</ul>
<p>go build -race<br>.&#x2F;test &#x2F;&#x2F;运行<br><img src="/images/goinaction26.png" alt="image.png"></p>
<h3 id="锁住共享资源"><a href="#锁住共享资源" class="headerlink" title="锁住共享资源"></a>锁住共享资源</h3><p>同步机制 : 对共享资源加锁</p>
<h4 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Schedule the call to Done to tell main we are done.</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">        <span class="comment">// Safely Add One To Counter.</span></span><br><span class="line">        atomic.AddInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Yield the thread and be placed back in queue.</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>atmoic</p>
<ul>
<li>AddInt64同步整型的加法</li>
<li>LoadInt64安全读整型值</li>
<li>StoreInt64安全写整型值</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>在代码上创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Schedule the call to Done to tell main we are done.</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">        <span class="comment">// Only allow one goroutine through this</span></span><br><span class="line">        <span class="comment">// critical section at a time.</span></span><br><span class="line">        mutex.Lock()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Capture the value of counter.</span></span><br><span class="line">            value := counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Yield the thread and be placed back in queue.</span></span><br><span class="line">            runtime.Gosched()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Increment our local value of counter.</span></span><br><span class="line">            value++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Store the value back into counter.</span></span><br><span class="line">            counter = value</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">        <span class="comment">// Release the lock and allow any</span></span><br><span class="line">        <span class="comment">// waiting goroutine through.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>可以在goroutine间做同步</p>
<ul>
<li>使用make创建通道(参数chan+允许通道交换的类型）</li>
</ul>
<p>（1）无缓冲通道：unbuffered :&#x3D; make(chan int)<br>需要发送goroutine和接收goroutine都准备好，才能完成发送和接收操作。没准备好会阻塞，保证同时交换数据<br><img src="/images/goinaction27.png" alt="image.png">)<br>（2）有缓冲通道：buffered :&#x3D; make(chan string, 10)<br>在被接收前能存储一个或者多个值的通道，通道中没有要接收的值时，才会阻塞。<br><img src="/images/goinaction28.png" alt="image.png"><br>close(chan) 关闭通道后，goroutine依然可以从通道接收数据，但是不能再向通道里发送数据 -&gt; 不会有数据丢失</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to use a buffered</span></span><br><span class="line"><span class="comment">// channel to work on multiple tasks with a predefined number</span></span><br><span class="line"><span class="comment">// of goroutines.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    numberGoroutines = <span class="number">4</span>  <span class="comment">// Number of goroutines to use.</span></span><br><span class="line">    taskLoad         = <span class="number">10</span> <span class="comment">// Amount of work to process.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// init is called to initialize the package by the</span></span><br><span class="line"><span class="comment">// Go runtime prior to any other code being executed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Seed the random number generator.</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a buffered channel to manage the task load.</span></span><br><span class="line">    tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, taskLoad)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch goroutines to handle the work.</span></span><br><span class="line">    wg.Add(numberGoroutines)</span><br><span class="line">    <span class="keyword">for</span> gr := <span class="number">1</span>; gr &lt;= numberGoroutines; gr++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(tasks, gr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a bunch of work to get done.</span></span><br><span class="line">    <span class="keyword">for</span> post := <span class="number">1</span>; post &lt;= taskLoad; post++ &#123;</span><br><span class="line">        tasks &lt;- fmt.Sprintf(<span class="string">&quot;Task : %d&quot;</span>, post)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the channel so the goroutines will quit</span></span><br><span class="line">    <span class="comment">// when all the work is done.</span></span><br><span class="line">    <span class="built_in">close</span>(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for all the work to get done.</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// worker is launched as a goroutine to process work from</span></span><br><span class="line"><span class="comment">// the buffered channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasks <span class="keyword">chan</span> <span class="type">string</span>, worker <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Report that we just returned.</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// Wait for work to be assigned.</span></span><br><span class="line">        task, ok := &lt;-tasks</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// This means the channel is empty and closed.</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Worker: %d : Shutting Down\n&quot;</span>, worker)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Display we are starting the work.</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;Worker: %d : Started %s\n&quot;</span>, worker, task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Randomly wait to simulate work time.</span></span><br><span class="line">        sleep := rand.Int63n(<span class="number">100</span>)</span><br><span class="line">        time.Sleep(time.Duration(sleep) * time.Millisecond)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Display we finished the work.</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;Worker: %d : Completed %s\n&quot;</span>, worker, task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/goinaction29.png" alt="image.png"></p>
<ul>
<li>向通道发送值 &lt;-</li>
</ul>
<p>buffered &lt;- “Gopher”</p>
<ul>
<li>从通道接收值</li>
</ul>
<p>value :&#x3D; &lt;- buffered</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><h3 id="log包"><a href="#log包" class="headerlink" title="log包"></a>log包</h3><ul>
<li>设置日志的前缀 ：log.SetPrefix(“TRACE: “)</li>
<li>设置写到日志项的信息 ： log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</li>
</ul>
<p>输出<br>TRACE: 2023&#x2F;06&#x2F;07 17:27:26.146249 &#x2F;mnt&#x2F;d&#x2F;code&#x2F;code-master&#x2F;chapter8&#x2F;listing03&#x2F;listing03.go:15: message<br><img src="/images/goinaction30.png" alt="image.png"><br>iota是内置常量生成器： 1&lt;&lt;iota 每个常量声明都将1按位左移iota个位置<br>log包是多goroutine安全的，多个goroutine可以调用来自同一个日志记录器的函数，不会有写冲突，用户定制的日志器也应该满足这个性质<br>（如果没有写入需求也可以没有互斥锁 team logging repo）<br>log.Logger内部维护了互斥锁mutex<br><img src="/images/goinaction31.png" alt="image.png"><br><img src="/images/goinaction32.png" alt="image.png"></p>
<h3 id="定制的日志记录器"><a href="#定制的日志记录器" class="headerlink" title="定制的日志记录器"></a>定制的日志记录器</h3><p>需要创建Logger类型值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to create customized loggers.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Trace   *log.Logger <span class="comment">// Just about anything</span></span><br><span class="line">    Info    *log.Logger <span class="comment">// Important information</span></span><br><span class="line">    Warning *log.Logger <span class="comment">// Be concerned</span></span><br><span class="line">    Error   *log.Logger <span class="comment">// Critical problem</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.OpenFile(<span class="string">&quot;errors.txt&quot;</span>,</span><br><span class="line">        os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Failed to open error log file:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Trace = log.New(ioutil.Discard,</span><br><span class="line">        <span class="string">&quot;TRACE: &quot;</span>,</span><br><span class="line">        log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Info = log.New(os.Stdout,</span><br><span class="line">        <span class="string">&quot;INFO: &quot;</span>,</span><br><span class="line">        log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Warning = log.New(os.Stdout,</span><br><span class="line">        <span class="string">&quot;WARNING: &quot;</span>,</span><br><span class="line">        log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Error = log.New(io.MultiWriter(file, os.Stderr),</span><br><span class="line">        <span class="string">&quot;ERROR: &quot;</span>,</span><br><span class="line">        log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Trace.Println(<span class="string">&quot;I have something standard to say&quot;</span>)</span><br><span class="line">    Info.Println(<span class="string">&quot;Special Information&quot;</span>)</span><br><span class="line">    Warning.Println(<span class="string">&quot;There is something you need to know about&quot;</span>)</span><br><span class="line">    Error.Println(<span class="string">&quot;Something has failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编码-x2F-解码"><a href="#编码-x2F-解码" class="headerlink" title="编码&#x2F;解码"></a>编码&#x2F;解码</h2><h3 id="解码json"><a href="#解码json" class="headerlink" title="解码json"></a>解码json</h3><p>http.Get() ，json unmarshal和 shouldbindjson（gin 框架中的 JSON 请求参数解析器，可以将客户端发送的 JSON 数据解析成 Go 结构体类型）都是将 JSON 数据解码为 Go 结构体的方法，但它们之间存在一些差异。</p>
<h4 id="json-NewDecoder-resp-Body-Decode-amp-gr"><a href="#json-NewDecoder-resp-Body-Decode-amp-gr" class="headerlink" title="json.NewDecoder(resp.Body).Decode(&amp;gr)"></a>json.NewDecoder(resp.Body).Decode(&amp;gr)</h4><p>使用了 json.Decoder 类型来处理 JSON 数据，并允许我们从输入流中逐步读取数据。这对于处理大型 JSON 数据或需要实时处理输入数据的情况非常有用。例如，在以下示例中，我们使用 http.Response 中的 Body 字段并使用 json.Decoder 类型从输入流中逐步读取 JSON 数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://jsonplaceholder.typicode.com/users/1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> user User</span><br><span class="line">    decoder := json.NewDecoder(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err := decoder.Decode(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(user.Name, user.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="json-Unmarshal-data-amp-gr"><a href="#json-Unmarshal-data-amp-gr" class="headerlink" title="json.Unmarshal(data, &amp;gr)"></a>json.Unmarshal(data, &amp;gr)</h4><p>函数接受一个字节数组或字符串作为输入，将其解析为指定类型的结构体，并将结果存储在传入的结构体变量中。例如，在以下示例中，我们使用 json.Unmarshal() 将 JSON 数据解码为 Person 结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">byte</span>(<span class="string">`&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> person Person</span><br><span class="line">    err := json.Unmarshal(data, &amp;person)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(person.Name, person.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var c map[string]interface{}<br>err :&#x3D; json.Unmarshal([]byte(JSON), &amp;c)<br>如果反序列化到map变量，值是interface{}类型（map[string]interface{})[“home”]）<br>原因：JSON 的数据类型是动态的，可以是字符串、数字、布尔值、数组、对象等多种类型，而在 Go 中 map 的值类型必须是固定的。因此，在将 JSON 数据反序列化为 Go map 变量时，需要将值类型设置为 interface{} 类型，以容纳任何可能的 JSON 数据类型。</p>
<h4 id="Gin框架中的ShouldBindJSON"><a href="#Gin框架中的ShouldBindJSON" class="headerlink" title="Gin框架中的ShouldBindJSON()"></a>Gin框架中的ShouldBindJSON()</h4><p>一个 Gin 框架提供的函数，用于将 HTTP 请求正文中的 JSON 数据绑定到指定的结构体中。如果请求正文中的 JSON 数据无法绑定到结构体，ShouldBindJSON() 会返回一个错误。例如，在以下示例中，我们使用 ShouldBindJSON() 将请求正文中的 JSON 数据绑定到 Person 结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.POST(<span class="string">&quot;/person&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> person Person</span><br><span class="line">        <span class="keyword">if</span> err := c.ShouldBindJSON(&amp;person); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.JSON(http.StatusOK, person)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 Person 的结构体类型，并使用 Gin 框架创建了一个 HTTP POST 路由来处理 JSON 数据。在路由处理程序中，我们使用 ShouldBindJSON() 函数将请求正文中的 JSON 数据绑定到 Person 结构体。如果绑定失败，则返回一个错误响应</p>
<p>type User struct {<br>Name string <code>json:&quot;name&quot;</code><br>Age  int    <code>json:&quot;age&quot;</code><br>}</p>
<ul>
<li>单引号声明的字符串被称作标签，将json文档和结构类型里的字段映射起来</li>
<li>没有标签的话，解码和编码会以大小写无关方式与字段名字匹配</li>
<li>若无法匹配，对应结构类型的字段就包含零值</li>
</ul>
<p>http.Get() （从互联网上获取数据，例如从 Web 服务器或 API 端点获取数据）和io.ReadAll()（将响应体的所有内容读取到一个字节数组中）函数会读取 Request.Body 中的所有数据并将其存储在内存中，这意味着连接仍然保持打开状态。如果不显式关闭请求体，则会导致客户端和服务器之间的连接一直打开，直到连接超时或客户端关闭连接为止<br><img src="/images/goinaction33.png" alt="image.png"><br><img src="/images/goinaction34.png" alt="image.png"><br>x.(T) 将接口类型转换为目标类型</p>
<h3 id="编码json"><a href="#编码json" class="headerlink" title="编码json"></a>编码json</h3><p>json.NewEncoder()、json.Marshal() 和 Gin 框架中的 JSON() 函数都是用于将 Go 结构体类型编码为 JSON 数据的方法，但它们之间存在一些差异。</p>
<h4 id="json-NewEncoder-："><a href="#json-NewEncoder-：" class="headerlink" title="json.NewEncoder()："></a>json.NewEncoder()：</h4><p>使用 json.Encoder 类型将 Go 结构体类型编码为 JSON 数据，并允许我们逐步写入输出流。这对于需要实时处理输出数据或处理大型 JSON 数据的情况非常有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">    encoder := json.NewEncoder(os.Stdout)</span><br><span class="line">    <span class="keyword">if</span> err := encoder.Encode(person); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上示例中，我们定义了一个名为 Person 的结构体类型，包含两个属性：Name 和 Age。然后，我们使用 json.NewEncoder() 将 Person 结构体类型编码为 JSON 数据，并将其输出到标准输出流中。</p>
<h4 id="json-Marshal"><a href="#json-Marshal" class="headerlink" title="json.Marshal()"></a>json.Marshal()</h4><p>将 Go 结构体类型编码为 JSON 数据，并将其作为字节数组返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">    data, err := json.Marshal(person)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上示例中，我们定义了一个名为 Person 的结构体类型，包含两个属性：Name 和 Age。然后，我们使用 json.Marshal() 将 Person 结构体类型编码为 JSON 数据，并将其存储在 data 变量中，最后打印 data 变量的内容。</p>
<h4 id="Gin-框架中的-JSON-函数"><a href="#Gin-框架中的-JSON-函数" class="headerlink" title="Gin 框架中的 JSON() 函数"></a>Gin 框架中的 JSON() 函数</h4><p>将 Go 结构体类型编码为 JSON 数据，并将其发送回客户端作为 HTTP 响应。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/person&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        person := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">        c.JSON(http.StatusOK, person)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上示例中，我们使用 Gin 框架创建了一个 HTTP GET 路由来处理请求，并使用 JSON() 函数将 Person 结构体类型编码为 JSON 数据，并将其作为响应发送回客户端。<br>对比：<br>c.PureJSON() 是一个函数，用于将一个结构体或 map 转换为 JSON 格式的字符串，并将其作为 HTTP 响应返回给客户端。与 c.JSON() 方法不同的是，c.PureJSON() 不会对数据进行 HTML 转义。这意味着如果您需要在 JSON 中包含特殊字符（例如 &lt;, &gt;, &amp;），则可以使用 c.PureJSON() 来避免这些字符被转义为 HTML 实体</p>
<p>总的来说，json.NewEncoder()、json.Marshal() 和 Gin 框架中的 JSON() 函数都是用于将 Go 结构体类型编码为 JSON 数据的方法。其中，json.NewEncoder() 对于处理大型 JSON 数据或需要实时处理输出数据的情况非常有用，而 json.Marshal() 则直接返回编码后的 JSON 字符串，而 Gin 框架中的 JSON() 函数则直接将编码后的 JSON 数据作为响应发送给客户端</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>只要实现了io.Writer和io.Reader两个接口，都可以使用io包提供的所有功能，也可以用于其他包里接收这两个接口的函数及方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sample program to show how different functions from the</span></span><br><span class="line"><span class="comment">// standard library use the io.Writer interface.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for the application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a Buffer value and write a string to the buffer.</span></span><br><span class="line">    <span class="comment">// Using the Write method that implements io.Writer.</span></span><br><span class="line">    <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">    b.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello &quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use Fprintf to concatenate a string to the Buffer.</span></span><br><span class="line">    <span class="comment">// Passing the address of a bytes.Buffer value for io.Writer.</span></span><br><span class="line">    fmt.Fprintf(&amp;b, <span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func Fprintf(w io.Writer, format string, a …any) (n int, err error)<br>Buffer实现了Writer方法 所以可以传入Fprintf函数里<br>func (b *Buffer) Write(p []byte) (n int, err error)</p>
<h1 id="测试和性能"><a href="#测试和性能" class="headerlink" title="测试和性能"></a>测试和性能</h1><p>需要遵守的规定</p>
<ul>
<li>go语言测试工具只会认为_test.go结尾的文件是测试文件</li>
</ul>
<p>（如果没有 go test命令时就会报：?       command-line-arguments  [no test files]）</p>
<ul>
<li>需要import testing 包</li>
<li>测试函数是公开函数（首字母大写），并以Test开头，必须接收testing.T类型的指针-&gt; 报告每个测试的输出和状态</li>
</ul>
<p>go test -v xxx_test.go<br>(-v 需要加入冗余选项）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">package listing01</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;testing&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">TestDownload</span><span class="params">(t *testing.T)</span></span></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go in action</tag>
      </tags>
  </entry>
  <entry>
    <title>Go mod</title>
    <url>/Go%20mod/</url>
    <content><![CDATA[<h1 id="Go-mod"><a href="#Go-mod" class="headerlink" title="Go mod"></a>Go mod</h1><ul>
<li><p>Go语言默认的依赖管理工具</p>
</li>
<li><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>go mod download</td>
<td>下载依赖包到本地（默认为 GOPATH&#x2F;pkg&#x2F;mod 目录）</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod graph</td>
<td>打印模块依赖图</td>
</tr>
<tr>
<td>go mod init</td>
<td>初始化当前文件夹，创建 go.mod 文件</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>增加缺少的包，删除无用的包</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>将依赖复制到 vendor 目录下</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验依赖</td>
</tr>
<tr>
<td>go mod why</td>
<td>解释为什么需要依赖</td>
</tr>
</tbody></table>
</li>
<li><p>export GOPROXY&#x3D;<a href="https://goproxy.cn/">https://goproxy.cn</a> 使用代理服务器</p>
</li>
<li><p>go.mod 文件一旦创建后，它的内容将会被 go toolchain 全面掌控，go toolchain 会在各类命令执行时，比如<code>go get</code>、<code>go build</code>、<code>go mod</code>等修改和维护 go.mod 文件</p>
</li>
<li><p>使用</p>
<ol>
<li><p>初始化生成go.mod文件</p>
<p><code>go mod init</code></p>
</li>
<li><p>go.mod 提供了 module、require、replace 和 exclude 四个命令：</p>
<ul>
<li>module 语句指定包的名字（路径）</li>
<li>require 语句指定的依赖项模块</li>
<li>replace 语句可以替换依赖项模块</li>
<li>exclude 语句可以忽略依赖项模块</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go basic</tag>
      </tags>
  </entry>
  <entry>
    <title>slice 和 map 线程安全问题</title>
    <url>/goinactionSliceMap/</url>
    <content><![CDATA[<h1 id="slice和map底层结构与源码"><a href="#slice和map底层结构与源码" class="headerlink" title="slice和map底层结构与源码"></a>slice和map底层结构与源码</h1><ul>
<li><p>slice源码位置在$GOPATH&#x2F;src&#x2F;runtime&#x2F;slice.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice结构类似vector, 底层是数组，传递的时候是传递的指针，长度和容量，是引用类型</p>
</li>
<li><p>map源码位置在$GOPATH&#x2F;src&#x2F;runtime&#x2F;map.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bucketCntBits = <span class="number">3</span></span><br><span class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line">	<span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line">	<span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">	<span class="comment">// Followed by bucketCnt keys and then bucketCnt elems.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span></span><br><span class="line">	<span class="comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span></span><br><span class="line">	<span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line">	<span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）map是数组存储的的，每个数组下标处存储的是一个bucket,这个bucket的类型见上面代码，每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表,看bmap的结构<br>（2）当往map中存储一个kv对时：<br>通过k获取hash值，hash值的低八位和bucket数组长度取余，定位到在数组中的那个下标<br>hash值的高八位存储在bucket中的tophash中，用来快速判断key是否存在<br>key和value的具体值则通过指针运算存储<br>当一个bucket满时，通过overfolw指针链接到下一个bucket<br><img src="/images/goinaction5.png" alt="image.png"></p>
</li>
</ul>
<h1 id="slice线程安全"><a href="#slice线程安全" class="headerlink" title="slice线程安全"></a>slice线程安全</h1><ul>
<li>多线程是slice是不安全的</li>
</ul>
<p>当容量不够，slice增长时，存在多线程竞争的问题：<br>下面这段代码for循环启动10个goroutine运行，每个goroutine向slice里添加一个元素a</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;len:%d, cap:%d, slice:%v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line"></span><br><span class="line">	wg.Add(n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			sum++</span><br><span class="line">			slice = <span class="built_in">append</span>(slice, a)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;a:%d, len:%d, cap:%d, slice:%v\n&quot;</span>, a, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len:%d, cap:%d, slice:%v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output:<br><img src="/images/goinaction6.png" alt="image.png"><br>运行看出，len(slice)不是预期的n，而小于了n<br>a&#x3D;7的时候， slice&#x3D;[9 4 5 6 7]<br>a&#x3D;3的时候，slice&#x3D;[9 4 5 6 3]<br>可以看出是在slice&#x3D;[9 4 5 6]时扩容，之前cap&#x3D;4, a&#x3D;7和a&#x3D;3的时候，同时扩容，将原来的9 4 5 6拷贝过来，并在新位置加上对应元素，两个goroutine同时运行，出现了索引位覆写问题<br>索引位覆写：同时修改相同索引位置的元素</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="goroutine等待其他goroutine完成任务"><a href="#goroutine等待其他goroutine完成任务" class="headerlink" title="goroutine等待其他goroutine完成任务"></a>goroutine等待其他goroutine完成任务</h3><p>for循环中对每个goroutine内部都增加了等待任务，必须等待其他goroutine完成才能继续执行，这样能安全的访问slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;len:%d, cap:%d, slice:%v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            sum++</span><br><span class="line">            slice = <span class="built_in">append</span>(slice, a)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;a:%d, len:%d, cap:%d, slice:%v\n&quot;</span>, a, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">        &#125;(i)</span><br><span class="line">        wg.Wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;len:%d, cap:%d, slice:%v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:<br><img src="/images/goinaction7.png" alt="image.png"><br>切片slice中相同索引下存放的值总是相同的</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>所有goroutine阻塞，无法并发执行，影响性能</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>对数据修改的时候加锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	mutex := sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;len:%d, cap:%d, slice:%v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line"></span><br><span class="line">	wg.Add(n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			mutex.Lock()</span><br><span class="line">			<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">			sum++</span><br><span class="line">			slice = <span class="built_in">append</span>(slice, a)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;a:%d, len:%d, cap:%d, slice:%v\n&quot;</span>, a, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len:%d, cap:%d, slice:%v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice), slice)</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output:<br><img src="/images/goinaction8.png" alt="image.png"><br>切片slice中相同索引下存放的值总是相同的</p>
<h1 id="map线程安全"><a href="#map线程安全" class="headerlink" title="map线程安全"></a>map线程安全</h1><ul>
<li>多线程是map是不安全的</li>
</ul>
<p>下面这段代码for循环启动10个goroutine运行，每个goroutine向map里添加一个元素a</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;len:%d, mp:%v\n&quot;</span>, <span class="built_in">len</span>(mp), mp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    wg.Add(n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            sum++</span><br><span class="line">            mp[a] = a</span><br><span class="line">            fmt.Printf(<span class="string">&quot;a:%d, len:%d, mp:%v\n&quot;</span>, a, <span class="built_in">len</span>(mp), mp)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len:%d, mp:%v\n&quot;</span>, <span class="built_in">len</span>(mp), mp)</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:<br><img src="/images/goinaction9.png" alt="image.png"><br>map线程不安全不能成功运行<br>解决方法和slice相似：加锁<br>修改后能成功运行</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go in action</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>[toc]</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><ul>
<li>有符号整型int8、int16、int32、int64</li>
<li>无符号整型uint8、uint16、uint32、uint64</li>
<li>int和uint对应特定CPU平台机器字大小的有符号和无符号整数</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><ul>
<li>Go语言提供了两种精度的浮点数，float32和float64</li>
<li>math.MaxFloat32表示float32能表示的最大数值</li>
</ul>
<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><ul>
<li>布尔值并不会隐式转换为数字值0或1</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>内置的len函数可以返回一个字符串中的字节数目</p>
</li>
<li><p>索引操作s[i]返回第i个字节的字节值</p>
</li>
<li><p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串,生成的新字符串将包含j-i个字节，i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">  fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">  fmt.Println(s[<span class="number">7</span>:]) <span class="comment">// &quot;world&quot;</span></span><br><span class="line">  fmt.Println(s[:])  <span class="comment">// &quot;hello, world&quot;</span></span><br><span class="line"></span><br><span class="line">* 试图访问超出字符串索引范围的字节将导致<span class="built_in">panic</span>异常</span><br><span class="line"></span><br><span class="line">* 字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的</span><br><span class="line"></span><br><span class="line">* 用<span class="string">``</span>表示原生的字符串面值，在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行</span><br><span class="line"></span><br><span class="line">* 原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景</span><br><span class="line"></span><br><span class="line">* Unicode每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的<span class="type">rune</span>整数类型（译注：<span class="type">rune</span>是<span class="type">int32</span>等价类型）</span><br><span class="line"></span><br><span class="line">* 将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">  fmt.Println(string(65))     // &quot;A&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</p>
</li>
<li><p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的</p>
</li>
<li><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换</p>
</li>
<li><p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类</p>
</li>
<li><p>将一个整数转为字符串fmt.Sprintf 或者 strconv.Itoa()</p>
</li>
<li><p>将字符串解析为整数strconv包Atoi() 或者 ParseInt()</p>
</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li><p>常量表达式在编译期计算</p>
</li>
<li><p>和变量声明一样可以批量声明多个常量</p>
</li>
<li><p>批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量声明可以使用iota常量生成器初始化，用于生成一组以相似规则初始化的常量</p>
</li>
<li><p>在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一(枚举)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器为没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换 如math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个无类型的常量被赋值给一个变量的时候，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">&#x27;a&#x27;</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组是一个由固定长度的特定类型元素组成的序列、</li>
<li>默认情况下，数组的每个元素都被初始化为元素类型对应的零值</li>
<li>如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span>             <span class="comment">// array of 3 integers</span></span><br><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以指定一个索引和对应值列表的方式初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD Currency = <span class="literal">iota</span> <span class="comment">// 美元</span></span><br><span class="line">    EUR                 <span class="comment">// 欧元</span></span><br><span class="line">    GBP                 <span class="comment">// 英镑</span></span><br><span class="line">    RMB                 <span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">symbol := [...]<span class="type">string</span>&#123;USD: <span class="string">&quot;$&quot;</span>, EUR: <span class="string">&quot;€&quot;</span>, GBP: <span class="string">&quot;￡&quot;</span>, RMB: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// &quot;3 ￥&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化时没用到的索引可以省略，未指定初始值的元素将用零值初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125; <span class="comment">// 100个元素的数组r，最后一个初始化为-1，其他都用0初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以直接通过&#x3D;&#x3D;比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的</li>
<li>函数调用传递数组参数时，函数参数变量接收的是一个复制的副本，对数组参数的任何的修改都是发生在复制的数组，可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者</li>
</ul>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><ul>
<li>Slice（切片）代表变长的序列</li>
<li>一个slice由三个部分构成：指针、长度和容量</li>
<li>内置的len和cap函数分别返回slice的长度和容量</li>
<li>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列，i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替</li>
<li>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大</li>
<li>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素</li>
<li>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素</li>
<li>slice之间不能比较，因此我们不能使用&#x3D;&#x3D;操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte）</li>
<li>slice唯一合法的比较操作是和nil比较，一个零值的slice等于nil，一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0</li>
<li>一个nil值的slice的行为和其它任意0长度的slice一样，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice</li>
<li>内置的make函数创建一个指定元素类型、长度和容量的slice，容量部分可以省略</li>
<li>append函数用于向slice追加元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="type">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, runes) <span class="comment">// &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用stack来模拟栈</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stack = <span class="built_in">append</span>(stack, v) <span class="comment">// push v</span></span><br><span class="line">top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// top of stack</span></span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// pop</span></span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li>Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V</li>
<li>内置的make函数可以创建一个map：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以用map字面值的语法创建map，同时还可以指定一些最初的key&#x2F;value：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>map[string]int&#123;&#125;</code>也可以创建空的map</li>
<li>内置的delete函数可以删除元素</li>
<li>通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ages[<span class="string">&quot;bob&quot;</span>] == <span class="number">0</span> <span class="comment">// true if &quot;bob&quot; is not in the map</span></span><br></pre></td></tr></table></figure>

<ul>
<li>禁止对map元素取址，因为map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效</li>
<li>遍历map</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>要按顺序遍历key&#x2F;value对，我们必须显式地对key进行排序</p>
</li>
<li><p>map类型的零值是nil</p>
</li>
<li><p>map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常</p>
</li>
<li><p>map的下标语法可以产生两个值；第二个是一个布尔值，用于报告元素是否真的存在</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;bob&quot;</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul>
<li>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            <span class="type">int</span></span><br><span class="line">    Name, Address <span class="type">string</span></span><br><span class="line">    DoB           time.Time</span><br><span class="line">    Position      <span class="type">string</span></span><br><span class="line">    Salary        <span class="type">int</span></span><br><span class="line">    ManagerID     <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的</li>
<li>结构体类型的零值是每个成员都是零值，如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0</li>
<li>考虑效率，较大的结构体通常会用指针的方式传入和返回</li>
<li>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员，匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径</li>
<li>不能同时包含两个类型相同的匿名成员。会导致名字冲突</li>
<li>匿名成员也有可见性的规则约束</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数，Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；json.MarshalIndent函数将产生整齐缩进的输出，该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data, err := json.Marshal(movies)</span><br><span class="line">data, err := json.MarshalIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串，结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写，json开头键名对应的值用于控制encoding&#x2F;json包的编码和解码的行为</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Date <span class="keyword">struct</span> &#123;</span><br><span class="line">  Year <span class="type">int</span> <span class="string">`json:&quot;Y&quot;`</span></span><br><span class="line">  Month <span class="type">int</span> <span class="string">`json:&quot;M&quot;`</span></span><br><span class="line">  Day <span class="type">int</span> <span class="string">`json:&quot;D,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	Day成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象	（这里false为零值）</p>
<ul>
<li>将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go basic</tag>
      </tags>
  </entry>
  <entry>
    <title>go in action chapter1-4</title>
    <url>/goinactionChapter1-4/</url>
    <content><![CDATA[<h2 id="Go-语言介绍"><a href="#Go-语言介绍" class="headerlink" title="Go 语言介绍"></a>Go 语言介绍</h2><h3 id="开发速度"><a href="#开发速度" class="headerlink" title="开发速度"></a>开发速度</h3><p>编译器严格<br>（1）编译器只关注直接被引用的库（没有被引用的库编译器会报错）<br>（2）声明未使用的变量会报错，由类型检查<br>（3）内存管理由编译器处理</p>
<h3 id="支持并发"><a href="#支持并发" class="headerlink" title="支持并发"></a>支持并发</h3><p>goroutine类似线程，但使用内存少于线程<br>通过内置的数据结构通道(channel)让用户在不同goroutine间同步发送消息，而不是让多个goroutine争夺同一个数据的使用权<br>goroutine使用通道发送数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">var wg sync.WaitGroup // 定义一个 WaitGroup 对象，用于等待一组 goroutine 的结束</span><br><span class="line">func printer(c chan int) &#123;</span><br><span class="line">    for i: = range c &#123; // 使用 for-range 循环读取 channel 中的数据，直到 channel 被关闭为止</span><br><span class="line">        fmt.Printf(&quot;receive i:%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done() // 计数减一</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    c: = make(chan int) // 创建一个整型 channel</span><br><span class="line">    go printer(c) // 在新的 goroutine 中打印 channel 中的数据</span><br><span class="line">    wg.Add(1) // 增加一个计数器，表示有一个 goroutine 在运行</span><br><span class="line">    for i: = 1;i &lt; 10;i++&#123;</span><br><span class="line">        c &lt; -i // 将数字写入 channel</span><br><span class="line">    &#125;</span><br><span class="line">    close(c) // 关闭 channel，通知 goroutine 停止阻塞并退出</span><br><span class="line">    wg.Wait() // 等待所有 goroutine 完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/goinaction1.png" alt="image.png"><br>在两个goroutine间传输数据是同步的，在goroutine间安全传输数据的方法不需要任何锁和同步机制<br>但是通道是不提供跨goroutine的数据访问保护机制：<br>（1）传输数据是副本，goroutine各自持有副本修改是安全的<br>（2）传输数据是指向数据的指针，读和写由不同的goroutine完成的，每个goroutine需要额外的同步动作</p>
<h3 id="go语言的类型系统"><a href="#go语言的类型系统" class="headerlink" title="go语言的类型系统"></a>go语言的类型系统</h3><p>无继承的类型系统，支持面向对象开发</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>（1）在java里，设计需要围绕接口展开，必须满足接口里的所有约束，需要显示声明这个类实现了接口</p>
<ul>
<li>首先定义了一个 Shape 接口，其中只包含一个 getArea() 方法。</li>
<li>分别创建了 Circle 和 Rectangle 类，都实现了 Shape 接口，并实现了 getArea() 方法来计算它们的面积。</li>
<li>在 main() 函数中，创建了一个 Circle 对象和一个 Rectangle 对象，并将它们作为 Shape 类型的参数传递给 getArea() 函数，以计算它们的面积。<br>java使用接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    double getArea();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Circle implements Shape &#123;</span><br><span class="line">    private double radius;</span><br><span class="line"></span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getArea() &#123;</span><br><span class="line">        return Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Rectangle implements Shape &#123;</span><br><span class="line">    private double width;</span><br><span class="line">    private double height;</span><br><span class="line"></span><br><span class="line">    public Rectangle(double width, double height) &#123;</span><br><span class="line">        this.width = width;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getArea() &#123;</span><br><span class="line">        return width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape c = new Circle(5);</span><br><span class="line">        Shape r = new Rectangle(3, 4);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Circle area: &quot; + c.getArea());</span><br><span class="line">        System.out.println(&quot;Rectangle area: &quot; + r.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在go里</p>
<ul>
<li>定义了两个结构体类型 Circle 和 Rectangle，并为它们分别定义了 area() 方法来计算它们的面积。</li>
</ul>
<p>Circle类型的方法和Rectangle类型的方法<br>（go里的函数和方法不同：函数是独立的代码块，没有属于特定类型，可以直接通过函数名进行调用<br>方法是与某个类型绑定的函数，可以被该类型的值或指针调用。方法通常用于描述该类型的行为和操作，并且可以访问该类型的成员变量。方法的定义需要在函数名前指定一个接收者参数，表示该方法属于哪个类型）</p>
<ul>
<li>定义了一个 Shape 接口，其中只包含一个 area() 方法。</li>
<li>在 getArea() 函数中，接收一个 Shape 类型的参数，并调用其 area() 方法来计算面积。</li>
<li>在 main() 函数中，创建了一个 Circle 类型的变量和一个 Rectangle 类型的变量，并分别将它们作为参数传递给 getArea() 函数。</li>
</ul>
<p>Circle 和 Rectangle 结构体类型并没有显式地声明它们实现了 Shape 接口，但由于它们都定义了 area() 方法，因此它们隐式地满足了 Shape 接口的要求。这就体现了Go语言中的“鸭子类型”特点，即只要一个结构体类型具备某个方法或操作，那么它就可以被看作具有相应接口的能力，无需显式地声明实现了该接口。</p>
<p>go使用接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Circle struct &#123;</span><br><span class="line">    radius float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">    width, height float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(c Circle) area() float64 &#123;</span><br><span class="line">    return math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(r Rectangle) area() float64 &#123;</span><br><span class="line">    return r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Shape interface &#123;</span><br><span class="line">    area() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getArea(s Shape) float64 &#123;</span><br><span class="line">    return s.area()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    c: = Circle &#123;</span><br><span class="line">        radius: 5</span><br><span class="line">    &#125;</span><br><span class="line">    r: = Rectangle &#123;</span><br><span class="line">        width: 3,</span><br><span class="line">        height: 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;Circle area:&quot;, getArea(c))</span><br><span class="line">    fmt.Println(&quot;Rectangle area:&quot;, getArea(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips: go online: <a href="https://go.dev/play/">https://go.dev/play/</a></p>
<h2 id="打包和工具链"><a href="#打包和工具链" class="headerlink" title="打包和工具链"></a>打包和工具链</h2><p>go语言的程序都会组织成若干组文件，每组文件被称为一个包<br>包名：<br>（1）使用包所在目录的名字 -&gt; 用户导入包的时候，能清晰知道包名<br>（2）全小写 -&gt; 有利于开发时频繁输入包名<br>（3）包名可以相同 -&gt; 导入包的时候使用全路径，可以区分同名的不同包</p>
<h3 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h3><p>（1）所有用go语言编译的可执行程序必须有一个名叫main的包<br>包名为main，一定也会有main函数，否则不会创建可执行文件 -&gt; main函数是程序入口<br>main包 里的go 源文件 都会被编译为二进制可执行文件<br>（2）不同目录下可以有多个 package main，但是同一目录下不能有多个 package main</p>
<h3 id="包导入"><a href="#包导入" class="headerlink" title="包导入"></a>包导入</h3><p>import (<br>“fmt”<br>“github.com&#x2F;spf12&#x2F;viper” &#x2F;&#x2F;远程导入<br>myfmt “mylib&#x2F;fmt”  &#x2F;&#x2F;命名导入<br>)<br>通过go module管理包（以前是在gopath环境变量目录下管理包）<br>go mod init modulename<br>go mod tidy -&gt; 查找下载依赖包</p>
<p>生成go.mod  go.sum</p>
<h3 id="函数init"><a href="#函数init" class="headerlink" title="函数init"></a>函数init</h3><p>每个包可以有多个init函数，这些函数在程序执行开始的时候被调用 -&gt; 在main函数之前执行<br>go语言要求不能导入不使用的包：<br>如果有init函数，但是该包里的内容没有被main函数使用，则使用空白标识符作为包的别名：<br>import (<br>“database&#x2F;sql”<br>_ “github.com&#x2F;goinaction&#x2F;code&#x2F;test”  &#x2F;&#x2F;避免编译错误<br>)</p>
<h3 id="使用go工具"><a href="#使用go工具" class="headerlink" title="使用go工具"></a>使用go工具</h3><p>编译： go build demo.go<br>清除编译生成文件： go clean<br>检查代码： go vet demo.go<br>代码格式化：go fmt demo.go</p>
<h2 id="数组以及切片和映射"><a href="#数组以及切片和映射" class="headerlink" title="数组以及切片和映射"></a>数组以及切片和映射</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>长度固定，存储一段相同类型的元素的连续块</p>
<h4 id="数组创建和初始化"><a href="#数组创建和初始化" class="headerlink" title="数组创建和初始化"></a>数组创建和初始化</h4><p>声明后类型和长度不能改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arry [5]int  -&gt; 声明时对应类型的零值来初始化</span><br><span class="line">var arry = [5]int&#123;1, 2, 3, 4, 5&#125; -&gt; 声明的时候初始化</span><br><span class="line">array := [5]int&#123;1,2,3,4,5&#125;  -&gt; 使用数组字面量声明数组</span><br><span class="line">array := [...]int&#123;1,2,3,4,5&#125;  -&gt; 自动计算声明数组长度</span><br><span class="line">array := [5]int&#123;1:10, 3:20&#125; -&gt; 声明数组，指定特定元素的值</span><br></pre></td></tr></table></figure>


<h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><p>（1）访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array[2] = 25 -&gt; 访问数组元素，并修改对应索引元素的值</span><br></pre></td></tr></table></figure>

<p>（2）指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array := [5]*int -&gt; 仅声明未初始化 不能直接使用</span><br><span class="line">array := [5]*int&#123;&#125; -&gt; 声明并初始化为nil</span><br><span class="line">array := [5]*int&#123;0:new(int), 1:new(int)&#125; -&gt; 整型指针初始化索引0和1的数组元素</span><br></pre></td></tr></table></figure>

<p>（3）同类型互相赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array1 [5]int</span><br><span class="line">array2 := [5]int&#123;1,2,3,4,5&#125;</span><br><span class="line">array1 = array2 -&gt; correct</span><br><span class="line">对比:</span><br><span class="line">var array1 [4]int</span><br><span class="line">array1 = array2 -&gt; not correct</span><br></pre></td></tr></table></figure>



<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>var array [4][2]int</p>
<h4 id="函数间传递数组"><a href="#函数间传递数组" class="headerlink" title="函数间传递数组"></a>函数间传递数组</h4><p>函数间传递变量，通过值传递，如果传递数组，会赋值整个数组的值  -&gt; 开销很大<br>solution: 传递指针，指针大小8字节 （64位系统） -&gt; 有效利用内存</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>围绕动态数组构建，按需增长减小。底层内存是在连续块中分配内存，对底层数组进行了抽象<br>切片有三个字段的数据结构：<br>（1）指向底层数组的指针<br>（2）长度：切片访问的元素的个数 len函数<br>（3）容量：切片允许增长到的元素个数 cap函数</p>
<h4 id="切片创建和初始化"><a href="#切片创建和初始化" class="headerlink" title="切片创建和初始化"></a>切片创建和初始化</h4><p>make和切片字面量<br>tips : make 函数主要用于创建和初始化某些类型的内置数据结构，例如 slice、map 和 channel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slice := make([]int, 3, 5) -&gt; make 使用长度，容量初始化（容量可省略，此时长度和容量相同）</span><br><span class="line">切片能访问3个元素，底层数据拥有5个</span><br><span class="line">slice := make([]int, 3, 2) -&gt; make 使用长度大于容量，编译报错</span><br><span class="line">slice := []int&#123;1,2,3&#125;  -&gt; 切片字面量（不指定[]的值，基于初始化的元素个数确定长度和容量)</span><br></pre></td></tr></table></figure>

<p>数组和切片声明的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]运算符里指定了值，创建的是数组 -&gt; slice := [3]int&#123;1,2,3&#125; -&gt; 三个元素的数组</span><br><span class="line">[]运算符里不指定值，创建的是切片 -&gt; slice := []int&#123;1,2,3&#125; -&gt; 长度容量都为3的切片</span><br></pre></td></tr></table></figure>

<p>声明空切片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slice : = make([]int, 0)</span><br><span class="line">slice := []int&#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h4><p>(1)共享底层数组的两个切片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slice := []int&#123;10,20,30,40,50&#125;</span><br><span class="line">newSlice := slice[1:3]  -&gt; 用切片创建切片</span><br></pre></td></tr></table></figure>



<p><img src="/images/goinaction2.png" alt="image.png"><br>新切片slice[i:j]的长度和容量, 底层数组的容量k<br>长度：j-i<br>容量：k-i<br>修改切片内容 -&gt; newSlice[1] &#x3D; 35 -&gt;slice第三个元素被修改为35</p>
<p>(2)切片额外的容量<br>1）切片只能访问到长度内的元素<br>2）与切片的容量相关联的元素只能用于增长切片，在使用这部分元素前，要将其合并到切片长度里<br>如果不能把这些合并到切片长度里，这些容量就没有用处（可使用append做合并）</p>
<p>(3)切片增长<br>append会创建新的底层数组，把现有的值赋值到新数组里，再追加新的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slice := []int&#123;10,20,30,40&#125;</span><br><span class="line">newSlice := append(slice, 50)</span><br></pre></td></tr></table></figure>

<p>newSlice有用全新的底层数组，这个数组是原来容量的两倍<br><img src="/images/goinaction3.png" alt="image.png"><br>append只能处理底层数组的容量增长，容量小于1000，两倍增长。超过1000，增长因子1.25</p>
<p>(4)创建切片的3个索引<br>限制容量，为顶层数组提供保护，控制追加操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source := []string&#123;&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &#x27;Banana&quot;, &#x27;Grape&quot;&#125;</span><br><span class="line">slice := source[2:3:4]</span><br><span class="line">source[i:j:k]</span><br><span class="line">长度：j-i</span><br><span class="line">容量：k-i</span><br></pre></td></tr></table></figure>


<p><img src="/images/goinaction4.png" alt="image.png"><br>(5)迭代切片: range<br>for index, value :&#x3D; range slice{<br>}<br>range返回：迭代到的索引位置，对应位置元素的副本（副本无法取地址，使用该值变量的地址作为指向每个元素的指针地址是一样的：&amp;value的值是一样的 -&gt; 需要用&amp;slice[index]）<br>不需要的值可以用占位符_表示忽略 -&gt; for _, value :&#x3D; range slice</p>
<h4 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slice := [][]int&#123;&#123;10&#125;,&#123;20,30&#125;&#125;  可以利用创建复杂数据结构</span><br></pre></td></tr></table></figure>


<h4 id="函数间传递切片"><a href="#函数间传递切片" class="headerlink" title="函数间传递切片"></a>函数间传递切片</h4><p>切片以值得方式传递给函数，只复制切片本素，不复制底层数组，所以只需要24个字节：指针8个字节，长度和容量分别8字节。<br>因此切片效率高，如果函数需要修改数据，传递回一份新得切片副本即可</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>存储无序键值对</p>
<h4 id="映射创建和初始化"><a href="#映射创建和初始化" class="headerlink" title="映射创建和初始化"></a>映射创建和初始化</h4><p>使用make声明（key value都是string类型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict := make(map[string]string)</span><br></pre></td></tr></table></figure>

<p>创建并初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict := map[string]string&#123;&quot;red&quot;:&quot;hello&quot;, &quot;yellow&quot;:&quot;world&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>映射的键不能是切片，包含切片的类型，函数的结构类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict := map[[]string]string&#123;&#125; -&gt; 编译报错</span><br></pre></td></tr></table></figure>

<p>可以作为映射的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict := map[string][]string&#123;&#125; -&gt; ok</span><br></pre></td></tr></table></figure>

<h4 id="使用映射"><a href="#使用映射" class="headerlink" title="使用映射"></a>使用映射</h4><p>为映射赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict := map[string]string&#123;&#125;</span><br><span class="line">dict[&quot;red&quot;] = &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>未初始化的映射 -&gt; nil映射 -&gt; 赋值运行错误：nil映射不能用于存储键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict := map[string]string</span><br><span class="line">dict[&quot;red&quot;] = &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>从映射获取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value, exist := dict[&quot;red&quot;]  -&gt; 返回映射键对应的值和该值是否存在，如果键不存在，exist返回false</span><br><span class="line">value := dict[&quot;red&quot;]</span><br><span class="line">if value != &quot;&quot;        -&gt; 判断value是否是零值来看映射键是否存在</span><br></pre></td></tr></table></figure>

<p>range 迭代映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key,value := range dict &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除映射中的一项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(dict, &quot;red&quot;)</span><br></pre></td></tr></table></figure>

<p>映射的增长没有容量限制：可通过len函数得到映射长度</p>
<h4 id="在函数间传递映射"><a href="#在函数间传递映射" class="headerlink" title="在函数间传递映射"></a>在函数间传递映射</h4><p>函数间传递映射不会制造错该映射的副本，如果对映射修改，所有对这个映射的引用都会察觉。特性与切片类似，传递给函数成本很小，不会复制底层的数据结构</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go in action</tag>
      </tags>
  </entry>
  <entry>
    <title>acm</title>
    <url>/acm/</url>
    <content><![CDATA[<h1 id="素数（埃拉托色尼筛法）"><a href="#素数（埃拉托色尼筛法）" class="headerlink" title="素数（埃拉托色尼筛法）"></a>素数（埃拉托色尼筛法）</h1><p>题目：给定一个数 n，打印所有小于或等于 n 的素数。</p>
<p>素数是恰好有两个不同的自然数约数的自然数：数字1和它本身，则素数不可能有因数</p>
<p>（1）2是最小的素数</p>
<p>（2）2的倍数则不是素数，将2的倍数的数字都进行标记</p>
<p>（3）按照这种方法标记所有数字，剩余没有标记的就是素数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrimeNumer</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> prime[num + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(prime, <span class="literal">true</span>, num + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; (i * i) &lt; (num + <span class="number">1</span>); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(prime[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt; (num + <span class="number">1</span>); j = j + i) &#123;</span><br><span class="line">				prime[j] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt; num + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(prime[i])</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">PrimeNumer</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output: 30以内的素数 2 3 5 7 11 13 17 19 23 29 </p>
<p>相关题目：给定两个整数 M 和 N，生成 M 和 N 之间的所有素数，包括 M 和 N。</p>
<p>解决方法，把第二个循环中取素数的范围改为（M,N), 如果M&lt;2, 则取的范围是从（2，N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> begin = <span class="built_in">max</span>(M, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = begin ; i &lt; N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span>(prime[i])</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>geek link: <a href="https://practice.geeksforgeeks.org/problems/sieve-of-eratosthenes5242/1">https://practice.geeksforgeeks.org/problems/sieve-of-eratosthenes5242/1</a></p>
<h1 id="模运算中的幂"><a href="#模运算中的幂" class="headerlink" title="模运算中的幂"></a>模运算中的幂</h1><p>给三个数 x, y and p, 计算(x^y) % p. </p>
<p>（1）y如果是奇数，则把x先乘以res;</p>
<p>最后一个y肯定是1，把之前的结果都乘给res</p>
<p>（2）计算x^y时需要注意，如果x,y很大，取幂次方容易越界，导致结果为0</p>
<p>因此每次计算结果需要取余后再进行下一次幂运算</p>
<p>（2）y左移一位后，x取平方记录在原始值中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PowerInmod</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//y如果是奇数，则把x先乘以res;</span></span><br><span class="line">        <span class="comment">//最后一个y肯定是1，把之前的结果都乘给res</span></span><br><span class="line">		<span class="keyword">if</span>(y % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">			res = (res * x) % p; <span class="comment">//先取余是为了如果x,y很大，取幂次方容易越界，导致结果为0</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//y左移一位，x乘以2，结果都保留在x中</span></span><br><span class="line">		<span class="comment">//y = y &gt;&gt; 1; 等价于下面这一行</span></span><br><span class="line">		y = y / <span class="number">2</span>;</span><br><span class="line">		x = (x * x) % p; <span class="comment">//先取余是为了如果x,y很大，取幂次方容易越界，导致结果为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">136</span>, y = <span class="number">926</span>, p = <span class="number">961</span>;</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">PowerInmod</span>(x, y, p);</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:165</p>
<h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><p>题目：找到整数系数 x 和 y，使得： ax + by &#x3D; gcd(a, b) </p>
<p>欧几里得算法：两个正整数的最大公约数等于较小的数和两数的余数的最大公约数</p>
<p>gcd(a,b) &#x3D; gcd(b%a, a)</p>
<p>gcd(b%a, a) &#x3D; b%a x1 + a y1</p>
<p>ax + by &#x3D; b%a x1 + a y1</p>
<p>ax + by &#x3D; (b-(b&#x2F;a * a))x1 +  a y1</p>
<p>ax + by &#x3D; a (y1 - b&#x2F;a x1) + b x1</p>
<p>综上，</p>
<p>x &#x3D; (y1 - b&#x2F;a x1)</p>
<p>y &#x3D;  x1</p>
<p>每次递归求最大公约数的时候，更新x, y的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GcdExtend</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> *x, <span class="type">int</span> *y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">		*x = <span class="number">0</span>;</span><br><span class="line">		*y = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x1, y1;</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">GcdExtend</span>(b%a, a, &amp;x1, &amp;y1);</span><br><span class="line">	*x = (y1 - (b/a) * x1);</span><br><span class="line">	*y = x1;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">int</span> gcd = <span class="built_in">GcdExtend</span>(a, b, &amp;x, &amp;y);</span><br><span class="line">	<span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;gcd, x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">GcdExtend</span>(<span class="number">35</span>, <span class="number">15</span>, &amp;x, &amp;y);</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output: 5</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef 函数与函数指针的使用</title>
    <url>/typedefFunc/</url>
    <content><![CDATA[<p>函数名是该函数的入口地址</p>
<p>函数指针：指向函数的指针，可以用来调用函数</p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>形式：typedef  返回类型(新类型)(参数列表)</p>
<p>（1）声明：新类型 *变量 (需要声明一个指针)</p>
<p>（2）初始化：变量 &#x3D; 函数返回地址</p>
<p>（3）使用：变量（参数列表）</p>
<p>此时的变量是一个指针，则可以指向一个函数的入口地址。可以将函数名赋值给该指针，来调用函数</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>形式：typedef  返回类型(*新类型)(参数列表)</p>
<p>（1）声明：新类型 变量</p>
<p>（2）初始化：变量 &#x3D; 函数返回地址</p>
<p>（3）使用：变量（参数列表）</p>
<p>此时的变量是直接就是一个指向函数的指针，可以将函数名赋值给该指针，来调用函数</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>typedef  函数: 就是重新定义了一个函数类型，如果需要调用则需要声明指向该函数类型的指针</li>
<li>typedef  函数指针: 是重新定义了一个指向函数类型的指针，要调用函数直接使用即可</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*funPoint_t)</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(<span class="type">function_t</span>)</span><span class="params">(<span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f0</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;f0, c = %c\n&quot;</span>, c); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;f1, c = %c\n&quot;</span>, c); <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    funPoint_t fp;<span class="comment">//fp是一个指向一个函数类型（返回的是int，参数是char）的函数指针</span></span><br><span class="line">    <span class="type">function_t</span> *fn;<span class="comment">//function_t是函数类型，所以fn是指向此函数类型的指针</span></span><br><span class="line"></span><br><span class="line">    fp = f0;</span><br><span class="line">    ret = <span class="built_in">fp</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//通过函数指针调用函数</span></span><br><span class="line"></span><br><span class="line">    fn = f1;</span><br><span class="line">    ret = <span class="built_in">fn</span>(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//通过函数指针调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f0, c = a</span><br><span class="line">f1, c = x</span><br></pre></td></tr></table></figure>

<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>含义：使用者实现一个函数，将该函数作为参数传给调用者的函数中，由调用者的函数在运行时来调用的函数。</p>
<p>即别人函数调用过程中来回调你实现的函数</p>
<p>（1）定义了一个函数指针类型：helloWorldFunc （函数指针类型可以直接使用，因为它直接指向了函数的入口地址）</p>
<p>（2）将helloWorld作为参数传给callBack方法，其中callBack的第一个参数是一个函数指针类型</p>
<p>（3）在callBack中调用helloWorld</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*helloWorldFunc)</span><span class="params">(string buffer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloWorld</span><span class="params">(string buffer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;string is:%s&quot;</span>, buffer.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callBack</span><span class="params">(helloWorldFunc fp, string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">fp</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">//helloWorldFunc fp = helloWorld;</span></span><br><span class="line">    <span class="comment">//callBack(fp, s);</span></span><br><span class="line">    <span class="comment">//上面两行等价于下面这一行</span></span><br><span class="line">	<span class="built_in">callBack</span>(helloWorld, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title>go package 使用</title>
    <url>/goPackage/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>环境：go version<br>go version go1.19.3 windows&#x2F;amd64</p>
<p>需要在main.go里导入自己写的包</p>
<p><img src="/images/goPackage.png" alt="项目结构"></p>
<p>在main.go里调用tempconv.go 出现error:</p>
<p>go run “d:\vsProject\gocode\main.go”<br>main.go:5:2: package tempconv is not in GOROOT (D:\soft\Go\src\tempconv)</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><ul>
<li><p>在go 1.11以前无法在除了root的目录下开发，1.11后提供了go mod来管理包</p>
</li>
<li><p>在同一目录下只能一个package</p>
</li>
</ul>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="GO-ENV"><a href="#GO-ENV" class="headerlink" title="GO ENV"></a>GO ENV</h2><p>设置GO111MODULE</p>
<p>on: 使用modules, 不会去gopath下查找</p>
<p>off: 不支持modules, 去gopath下查找</p>
<p>auto: 根据当前目录决定是否启动modules</p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GO111MODULE=off</span><br><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure>

<h3 id="winodows"><a href="#winodows" class="headerlink" title="winodows"></a>winodows</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set GO111MODULE=off</span><br><span class="line">set GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p>或者设置系统环境变量</p>
<h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>（1）关闭 go mod 模式：设置GO111MODULE off</p>
<p>（2）go env查看当前的GOPATH,  将需要导入的tempconv.go放入$GOPATH&#x2F;src下</p>
<p>note: 不建议这种方式，需要修改$GOPATH&#x2F;src</p>
<h2 id="GO-MOD"><a href="#GO-MOD" class="headerlink" title="GO MOD"></a>GO MOD</h2><p>（1）打开 go mod 模式：设置GO111MODULE off</p>
<p>（2）go mod init xx</p>
<p>（3）import xxx&#x2F;filename</p>
<p>go mod init gocode</p>
<p>项目结构：</p>
<p>gocode</p>
<p>—-module&#x2F;tempconv.go</p>
<p>—-main.go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;gocode/module&quot;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go package</tag>
      </tags>
  </entry>
  <entry>
    <title>学习计划</title>
    <url>/studyPlan/</url>
    <content><![CDATA[<h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><table>
<thead>
<tr>
<th>Summary</th>
<th>Tasks</th>
<th>Effort Estimastion</th>
<th>Comment</th>
</tr>
</thead>
<tbody><tr>
<td>preparation（11月）</td>
<td>学习书籍</td>
<td>1 day</td>
<td>The Go Programming Language： <a href="https://gopl-zh.github.io/">https://gopl-zh.github.io/</a>     Go in action ebook</td>
</tr>
<tr>
<td></td>
<td>博客网站</td>
<td>5 days</td>
<td>hexo 搭建博客网站： <a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a></td>
</tr>
<tr>
<td></td>
<td>笔记工具</td>
<td>2 day</td>
<td>Typora：所见即所得 <a href="https://zahui.fan/posts/64b52e0d/">https://zahui.fan/posts/64b52e0d/</a></td>
</tr>
<tr>
<td>knowledge（12月）</td>
<td>go基础知识(数据类型+函数)</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>方法+接口</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Goroutines ,Channels+并发</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>包+测试+反射</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td>practice（1月）</td>
<td>go项目练习（打包+工具链）</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>数组，切片+映射</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>类型系统</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>并发</td>
<td>3 days</td>
<td></td>
</tr>
<tr>
<td>project</td>
<td>github： go web</td>
<td>15 days</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p>（1）博客评论</p>
<p>（2）ui menu 优化</p>
<p>（3）blog url link</p>
<p>（4）git push+git desktop</p>
<p>（5）hexo picture</p>
]]></content>
      <categories>
        <category>plan</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 常用命令</title>
    <url>/linuxCommand/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>切换不同文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:e filename </span><br></pre></td></tr></table></figure>

<p>dd 删除一行</p>
<p>gg dG 删除所有</p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>main command</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull 拉image</span><br><span class="line">docker run 跑image</span><br><span class="line">docker ps 查看当前运行的image</span><br><span class="line">docker stop 停止container</span><br><span class="line">docker rm 删除container</span><br></pre></td></tr></table></figure>

<p>debug contaniner</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs [-f]  查看container的log</span><br><span class="line">docker exec -it containerId /bin/bash 进入容器  使用/bin/sh进入后,直接显示的是#，而使用/bin/bash直接显示的是root@xxxx:/#</span><br><span class="line">docker stat 查看容器资源的使用情况，CPU、内存、网络 I/O等</span><br><span class="line">docker inspect 查看容器控制的各种结构的详细信息</span><br></pre></td></tr></table></figure>

<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>把一个json文件在terminal pretty查看</p>
<p>(1) 使用python tool</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [file] | python3 -m json.tool </span><br></pre></td></tr></table></figure>

<p>(2) 使用jq 解析工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat [file] | jq .</span><br></pre></td></tr></table></figure>

<p>jq还可以直接定位对应json中key的value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat test.txt|jq .</span><br><span class="line">&#123;</span><br><span class="line">  &quot;foo&quot;: &#123;</span><br><span class="line">    &quot;bar&quot;: &#123;</span><br><span class="line">      &quot;baz&quot;: 123</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cat test.txt|jq &quot;.foo&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;bar&quot;: &#123;</span><br><span class="line">    &quot;baz&quot;: 123</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h1><p>在file.h中找到xxx代表的含义</p>
<p>In file.h</p>
<p>#define xxx “hello world”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep xxx file.h | cut -d &#x27;&quot;&#x27; -f2</span><br></pre></td></tr></table></figure>

<p>输出hello world，命令类似split用法，f1(#define xxx ) f2(hello world)</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>basic</title>
    <url>/basic/</url>
    <content><![CDATA[<ul>
<li>Go is especially well suited for building infrastructure like <strong>networked servers</strong>, and <strong>tools</strong> and <strong>systems</strong> for programmers</li>
<li>Its facilities for <strong>concurrency</strong> are new and efficient</li>
<li>It has <strong>automatic memory management</strong> or <strong>garbage collection</strong>.</li>
<li>Go 是一门编译型语言</li>
<li>Hello World<br>  $ go run helloworld.go<br>  $ go build helloworld.go</li>
</ul>
<ul>
<li>Go 语言的代码通过<strong>package</strong>组织<ol>
<li>类似于其它语言里的库或者模块</li>
<li><code>main</code> 包比较特殊。它定义了一个独立可执行的程序，main包中的main函数是整个程序执行的入口</li>
</ol>
</li>
</ul>
<ul>
<li>紧随在<strong>package</strong>声明后的<strong>import</strong>声明是导入的包</li>
<li>import之后是存储在该文件中的程序语句</li>
<li>go语言的编译过程没有警告⚠️信息</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go basic</tag>
      </tags>
  </entry>
</search>
